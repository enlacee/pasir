<!DOCTYPE html> <html lang="es"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/> <meta content="width=device-width,initial-scale=1,viewport-fit=cover" name="viewport"/> <title>LOGICSOFT ‚Äî TON / TOFF</title> <link href="./manifest.json" rel="manifest"/> <meta content="#003366" name="theme-color"/> <link href="https://pasir2025.github.io/SIMULADOR-LOGO/icons/icon-192.png" rel="icon"/> <meta content="yes" name="apple-mobile-web-app-capable"/> <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/> <link href="https://pasir2025.github.io/SIMULADOR-LOGO/icons/icon-192.png" rel="apple-touch-icon"/> <style>
  :root{
    --sidebar:#f3e5ab;
    --node:#fff8dc;
    --pin:#222;
    --wire:#000;
    --neon:#00ff66;
    --accent:#444;

    --pin-long:30px;
    --pin-hit-h:35px;
    --pin-visible-h:9px;
    --round-pin:35px;

    --workspace-size:5000px;
  }

  html,body{height:100%}
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;display:flex;height:100vh;overflow:hidden;background:#fff}

  /* Topbar */
  #topbar{
    position:fixed; inset:0 0 auto 0; height:46px; background:#ffffffcc; backdrop-filter:saturate(1.2) blur(6px);
    display:flex; align-items:center; gap:8px; padding:6px 8px; z-index:250; border-bottom:1px solid #e7e7e7;
  }
  #burger{font-size:20px; font-weight:900; padding:6px 10px; border:1px solid #777; border-radius:8px; background:#fff; cursor:pointer}
  #topbar button{padding:6px 10px;border-radius:8px;border:1px solid #777;background:#fff;font-weight:700;cursor:pointer}
  #spacer{flex:1}

  /* Sidebar (biblioteca) */
  #sidebar{
    position:fixed; top:46px; bottom:0; left:0; width:180px; background:var(--sidebar); padding:10px;
    border-right:3px solid #bdb089; display:flex; flex-direction:column; gap:8px; box-sizing:border-box; z-index:200;
    transform:translateX(-100%); transition:transform .18s ease;
    overflow-y:auto;
    -webkit-overflow-scrolling:touch;
    overscroll-behavior:contain;
    touch-action:pan-y;
  }
  #sidebar.open{transform:translateX(0)}
  #sidebar .component{touch-action:pan-y;}
  #sidebar > div[style*="font-weight"]{font-size:13px}
  .component{background:var(--node);border:2px solid #7a7a7a;border-radius:8px;padding:6px;text-align:center;cursor:grab;user-select:none;font-weight:700;font-size:20px;line-height:1.05;box-shadow:0 2px 0 rgba(0,0,0,.06)}
  .component.selected{outline:3px solid #0078d7;outline-offset:2px}

  /* Canvas */
  #canvas{flex:1;background:#fff;position:absolute; inset:46px 0 0 0; overflow:hidden; touch-action:none}
  #workspace{position:absolute;top:0;left:0;width:var(--workspace-size);height:var(--workspace-size);transform-origin:0 0;background:transparent}

  /* Bloques */
  .node{position:absolute;background:var(--node);border:3px solid var(--accent);border-radius:10px;width:150px;height:225px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;cursor:move;user-select:none;padding:8px;box-sizing:border-box;box-shadow:0 6px 0 rgba(0,0,0,.06);z-index:10;touch-action:none}
  .label{font-weight:900;margin-bottom:6px;pointer-events:none;color:#222;font-size:60px;line-height:1.05}
  .selected{box-shadow:0 10px 18px rgba(0,0,0,.12);border-color:#0058a3!important;transform:translateY(-2px)}
  .node.has-signal{border-color:var(--neon)!important; box-shadow:0 0 0 2px rgba(0,255,102,.25), 0 6px 0 rgba(0,0,0,.06)}

  /* Badge B001‚Ä¶ */
  .badge{position:absolute;top:6px;left:6px;padding:4px 10px;border-radius:12px;border:2px solid #003366;background:#fff;color:#003366;font-weight:900;font-size:18px;line-height:1;pointer-events:none;user-select:none;box-shadow:0 2px 0 rgba(0,0,0,.06)}

  /* Pines */
  .terminal{position:absolute;cursor:pointer;border-radius:8px;box-shadow:0 1px 0 rgba(0,0,0,.08);height:var(--pin-hit-h);background:transparent}
  .terminal::before{content:"";position:absolute;left:0;right:0;top:50%;transform:translateY(-50%);height:var(--pin-visible-h);border-radius:4px;background:var(--pin);display:block}
  .terminal.input{width:var(--pin-long);left:calc(-1 * var(--pin-long))}
  .terminal.output{width:var(--pin-long);right:calc(-1 * var(--pin-long));top:50%;transform:translateY(-50%)}
  .terminal.output.out-round{width:var(--round-pin);right:calc(-1 * var(--round-pin))}
  .terminal.output.out-round::before{width:var(--round-pin);height:var(--round-pin);border-radius:50%;background:#000;left:auto;right:0}
  .terminal.pin-selected::before{background:#0078d7!important;box-shadow:0 0 0 3px rgba(0,120,215,.25)}
  .terminal.pin-target{outline:2px solid #0078d7;outline-offset:2px}
  .terminal.signal-on::before{background:var(--neon)!important}
  .term-label{position:absolute;left:calc(-1 * var(--pin-long) - 36px);width:40px;text-align:right;font-size:12px;color:#222;user-select:none}

  /* Cables */
  #wires{position:absolute;top:0;left:0;width:var(--workspace-size);height:var(--workspace-size);pointer-events:auto;z-index:6}
  .wire-hit{fill:none;stroke:#000;stroke-width:40;stroke-opacity:0;vector-effect:non-scaling-stroke;pointer-events:stroke;stroke-linecap:round}
  .wire-path{fill:none;stroke:var(--wire);stroke-width:5;vector-effect:non-scaling-stroke;pointer-events:stroke}
  .wire-path.signal{stroke:var(--neon);stroke-width:6;filter:drop-shadow(0 0 8px rgba(0,255,102,.25))}
  .wire-path.selected{stroke:#0078d7;stroke-width:6}
  .wire-path.ghost{stroke-dasharray:6 6;opacity:.75}

  /* Hubs (juntas) */
  .hub-dot{fill:#000;stroke:#000;stroke-width:3;pointer-events:all;cursor:grab}
  .hub-hit{fill:#000;fill-opacity:0;pointer-events:all;cursor:grab}
  .hub-dot.signal{fill:var(--neon);stroke:var(--neon);filter:drop-shadow(0 0 8px rgba(0,255,102,.45))}

  /* Handles (nodos) */
  .bend-handle{fill:#fff;stroke:#0078d7;stroke-width:2.5px;r:11;cursor:grab;pointer-events:all}
  .bend-handle.dragging{fill:#e6f3ff}
  .bend-hit{fill:#000;fill-opacity:0;r:24;pointer-events:all}

  /* Etiquetas */
  .conn-tag{position:absolute;transform:translate(-50%,-50%);background:#fff;border:3px solid #003366;color:#003366;border-radius:12px;padding:6px 12px;font-weight:900;font-size:27px;line-height:1;box-shadow:0 2px 0 rgba(0,0,0,.06);user-select:none;z-index:20;cursor:grab}
  .conn-tag-src{background:#003366;color:#fff}
  .conn-tag.selected{outline:3px solid #0078d7;outline-offset:2px}
  .conn-tag.signal{background:var(--neon);color:#000;border-color:var(--neon);box-shadow:0 0 12px rgba(0,255,102,.45)}

  /* Indicador Q */
  .q-indicator{width:18px;height:18px;border-radius:50%;background:#444;margin-top:8px;pointer-events:none;border:2px solid #222}
  .q-indicator.on{background:var(--neon);box-shadow:0 0 8px rgba(0,255,102,.45)}

  #brand{position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,.06);padding:8px 12px;border-radius:8px;font-weight:900;letter-spacing:1px;z-index:60;box-shadow:0 6px 0 rgba(0,0,0,.04)}

  #installBtn{display:none;position:fixed;right:12px;bottom:80px;z-index:210;background:#003366;color:#fff;border:none;padding:10px 14px;border-radius:10px;font-weight:900;cursor:pointer;box-shadow:0 6px 0 rgba(0,0,0,.12)}

  /* FAB y paleta m√≥vil */
  #fabPalette{position:fixed;left:12px;bottom:12px;z-index:210;background:#003366;color:#fff;border:none;padding:12px 14px;border-radius:999px;font-weight:900;cursor:pointer;box-shadow:0 6px 0 rgba(0,0,0,.12);display:none}
  #paletteModal{position:fixed;inset:0;display:none;z-index:220;background:rgba(0,0,0,.35)}
  #paletteSheet{position:absolute;left:0;right:0;bottom:0;background:#fff;border-radius:16px 16px 0 0;padding:14px;border-top:3px solid #003366}
  #paletteGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  .pick{background:#fff8dc;border:2px solid #7a7a7a;border-radius:10px;padding:10px;font-weight:800;font-size:20px;text-align:center;cursor:pointer}

  /* Men√∫ contextual del cable */
  #wireMenu{position:fixed;z-index:230;display:none;background:#fff;border:2px solid #00366; border-color:#003366;border-radius:12px;box-shadow:0 10px 24px rgba(0,0,0,.18);overflow:hidden}
  #wireMenu button{display:block;width:100%;background:#fff;border:0;border-bottom:1px solid #e5e5e5;padding:10px 14px;font-weight:800;cursor:pointer;text-align:left}
  #wireMenu button:last-child{border-bottom:0}
  #wireMenu button:hover{background:#f5f9ff}

  /* Modal temporizador */
  #timerModal{position:fixed;inset:0;display:none;z-index:300;background:rgba(0,0,0,.4)}
  #timerCard{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;border-radius:12px;border:2px solid #003366;box-shadow:0 10px 24px rgba(0,0,0,.2);padding:14px;min-width:280px}
  #timerCard h3{margin:0 0 8px;font-size:18px;color:#003366}
  #timerCard label{display:block;font-weight:700;margin-bottom:6px}
  #timerCard input{width:100%;padding:8px;border:2px solid #bbb;border-radius:8px;font-weight:700}
  #timerActions{display:flex;gap:10px;justify-content:flex-end;margin-top:12px}
  #timerActions button{padding:8px 10px;border-radius:8px;border:1px solid #777;background:#fff;font-weight:800;cursor:pointer}
  #btnTimerSave{background:#003366;color:#fff;border-color:#003366}

  @supports(padding:max(0px)){
    #installBtn{bottom:calc(80px + env(safe-area-inset-bottom))}
    #fabPalette{bottom:calc(12px + env(safe-area-inset-bottom))}
  }
  @media (max-width:720px){
    #fabPalette{display:block}
  }

  /* Mejoras de pines: √°rea t√°ctil mayor e indicador de NOT en entradas */
  .terminal { touch-action: manipulation; }
  .terminal::after{ content:""; position:absolute; left:-6px; right:-6px; top:-6px; bottom:-6px; }
  .terminal.input.not::after{ /* circulito de inversi√≥n al borde izquierdo */ 
    content:""; position:absolute; left:-8px; top:50%; width:12px; height:12px; transform:translateY(-50%);
    border-radius:50%; background:#fff; border:3px solid var(--pin);
  }
  .terminal.input.not::before{ background:var(--pin); box-shadow:0 0 0 2px rgba(0,0,0,.15) inset; }


  #canvas {
    background: #ccc; /* gray non-workable area */
  }
  #workspace {
    background: #fff; /* workable area stays white */
    box-shadow: 0 0 0 2px #000 inset; /* optional border */
  }


/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}



/* === Assistant: Etiqueta superior para I/Q === */



.io-badge{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  padding:0;
  background:transparent;
  color:inherit;
  border:none;
  font-weight:900;
  font-size:120%;
  line-height:1;
  pointer-events:none;
  user-select:none;
  white-space:nowrap;
  box-shadow:none;
  z-index:6;
}



.node.has-io-badge{ padding-top:14px; }








/* === Assistant: IO badge centered inside node (matches badge style) === */



.io-badge{
  position:absolute;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  padding:0;
  background:transparent;
  color:inherit;
  border:none;
  font-weight:900;
  font-size:120%;
  line-height:1;
  pointer-events:none;
  user-select:none;
  white-space:nowrap;
  box-shadow:none;
  z-index:6;
}








.node.has-io-badge{ /* usually no extra padding needed since it's absolute */ }


/* Indicator circle for negated input pin without altering pin geometry */
.terminal.input.not::after{
  content:"";
  position:absolute;
  right:-8px; /* positioned to the right of the pin */
  top:50%;
  transform: translateY(-50%);
  width:12px;
  height:12px;
  border-radius:50%;
  background:#000;
  pointer-events:none;
  box-shadow:0 0 0 2px rgba(0,0,0,.15) inset;
}

/* --- icon buttons --- */
button#simulate, button#stop,
button#btnSave, button#btnLoad, button#btnNew,
button#btnEdit, button#deleteBtn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
button#simulate svg, button#stop svg,
button#btnSave svg, button#btnLoad svg, button#btnNew svg,
button#btnEdit svg, button#deleteBtn svg {
  flex: 0 0 auto;
}


/* --- Splash mode --- */
body.splash #workspace { display: none !important; }
#splashOverlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none; /* overlay is visual only */
}
#splashCard {
  text-align: center;
  font-family: inherit;
}
#splashTitle {
  font-size: 42px;
  font-weight: 900;
  color: #0047ff; /* mismo azul que botones */
  text-shadow: 0 0 6px rgba(255,255,255,0.7);
  letter-spacing: 1px;
}
#splashSubtitle {
  margin-top: 10px;
  font-size: 14px;
  color: #1f2937;
  opacity: 0.9;
  font-weight: 700;
}
/* opcional: atenuar el fondo del lienzo si por alguna raz√≥n se renderiza detr√°s */
body.splash { background: #f7f9fc; }




.btn-soporte {
    position: fixed;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #4CAF50; /* verde claro */
    color: #fff;
    border: none;
    padding: 10px 18px;
    border-radius: 999px; /* pastilla redonda */
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    box-shadow: 0 4px 10px rgba(0,0,0,0.25);
    z-index: 9999;
}

/* === Modal flotante para desbloqueo TON/TOFF/SR === */
.modal-overlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(15,23,42,0.75);
  z-index:99999;
}
.modal-card{
  background:#0b1120;
  color:#e5e7eb;
  width:90%;
  max-width:360px;
  padding:18px 18px 16px;
  border-radius:18px;
  box-shadow:0 18px 40px rgba(0,0,0,0.6);
  font-family:inherit;
}
.modal-card h3{
  margin:0 0 6px;
  font-size:18px;
  font-weight:800;
  color:#e5e7eb;
}
.modal-card p{
  margin:4px 0 12px;
  font-size:14px;
  color:#cbd5f5;
}
.option-item{
  display:flex;
  align-items:center;
  gap:8px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid #1d4ed8;
  margin:6px 0;
  cursor:pointer;
  font-size:14px;
  background:#020617;
  transition:background .15s ease, border-color .15s ease, transform .1s ease;
}
.option-item span{
  color:#e5e7eb;
}
.option-item:hover{
  background:#1e293b;
  transform:translateY(-1px);
}
.option-item.selected{
  border-color:#22c55e;
  background:#064e3b;
}
.modal-wa-row{
  display:flex;
  justify-content:flex-end;
  margin-top:8px;
}

.modal-buttons{
  display:flex;
  justify-content:flex-end;
  gap:10px;
  margin-top:14px;
}
.modal-buttons button{
  border-radius:999px;
  border:1px solid #64748b;
  background:#020617;
  padding:6px 14px;
  font-size:13px;
  font-weight:700;
  cursor:pointer;
  color:#e5e7eb;
}

#btnValidarCodigo{
  background:#16a34a;
  border-color:#15803d;
  color:#fff;
}
#btnValidarCodigo:hover{
  background:#15803d;
}
#okSoporte{
  border-radius:999px;
  border:1px solid #15803d;
  background:#16a34a;
  padding:6px 18px;
  font-size:13px;
  font-weight:700;
  cursor:pointer;
  color:#fff;
}
#okSoporte:hover{
  background:#15803d;
}
#cancelSoporte:hover{
  background:#111827;
}

/* Caja de c√≥digo de activaci√≥n */
.codigo-box{
  margin-top:12px;
  padding-top:10px;
  border-top:1px solid rgba(148,163,184,0.6);
  font-size:12px;
  color:#cbd5f5;
}
.codigo-row{
  display:flex;
  gap:8px;
  margin:6px 0;
}
.codigo-row input{
  flex:1;
  padding:6px 8px;
  border-radius:999px;
  border:1px solid #475569;
  background:#020617;
  color:#e5e7eb;
  font-size:13px;
}
.codigo-row button{
  border-radius:999px;
  border:1px solid #22c55e;
  background:#16a34a;
  color:#fff;
  font-size:12px;
  padding:6px 10px;
  cursor:pointer;
  font-weight:700;
}
.codigo-row button:hover{
  background:#15803d;
}


.btn-soporte:hover {
    background-color: #45BF5A; /* verde un poco m√°s intenso al pasar el mouse */
}


</style> <div id="uuidMachine">5bb0ff35-3abb-4766-8972-5bda4eb553b0</div> <style>
  #delete-debug{position:fixed;right:10px;bottom:10px;background:#111;color:#fff;
  font:12px/1.2 system-ui,Segoe UI,Roboto,Arial,sans-serif;border-radius:8px;
  padding:8px 10px;opacity:.85;z-index:999999;display:none}
  #delete-debug b{color:#93c5fd}

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> /* Simulate active visual */ <style>
  #simulate.active{
    background:#16a34a !important;
    color:#fff !important;
    border-color:#0f7a36 !important;
    box-shadow:0 0 0 2px rgba(22,163,74,.25) inset;
  }
html.theme-dark #simulate.active{
  background: #00ff66 !important; /* neon green */
  color:#000 !important;
  border-color:#00cc55 !important;
  box-shadow: 0 0 0 3px rgba(0,255,102,.45) inset !important;
}


/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style>
/* === Indicador de inversi√≥n estilo NOT en ENTRADAS (Opci√≥n B) === */
.terminal.input.not{ /* keep default size/position */ }
.terminal.input.not::before {
  content:""; position:absolute; width: var(--round-pin); height: var(--round-pin);
  border-radius:50%; background:#000; top:50%; transform:translateY(-50%); left:auto; right:0;
}
.terminal.input.not::after { content:none !important; }
/* Se√±al activa ‚Üí ne√≥n + glow */
.terminal.input.not.signal-on::before {
  background: var(--neon);
  filter: drop-shadow(0 0 8px rgba(0,255,102,.45));
  border:none;
}

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="assistant-injected" media="all">
    /* assistant-injected-pwa-and-ui */
    /* Sidebar visible y scrolleable; grid de bloques */
    #sidebar {
      width: clamp(140px, 26vw, 220px);
      overflow: auto;
      display: grid;
      grid-template-columns: 1fr;
      align-content: start;
      gap: 8px;
      -webkit-overflow-scrolling: touch;
    }

    /* En horizontal, sidebar fijo abierto (si tu app usa clases, esto ayuda) */
    @media (orientation: landscape) {
      #sidebar { transform: none !important; }
    }

    /* √Årea de trabajo ajusta cuando sidebar est√° fijo */
    #canvas {
      outline: none;
    }

    /* Zonas t√°ctiles de pines m√°s grandes sin cambiar lo visual */
    :root {
      --pin-hit-h: 44px;
      --pin-visible-h: 10px;
      --pin-long: 40px;
      --round-pin: 40px;
    }

    .terminal {
      position: absolute;
      touch-action: manipulation;
    }
    .terminal::after {
      content: "";
      position: absolute;
      left: -10px; right: -10px; top: -10px; bottom: -10px; /* hitbox agrandado */
    }

    /* Bot√≥n de simular con estados (por si lo usas) */
    .simulate-btn.is-on { filter: saturate(1.3); }
    .simulate-btn.is-off { opacity: .7; }
    
/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="assistant-toggle-sidebar">
/* Toggle sidebar via .open incluso en landscape */
#sidebar{ transition: transform .2s ease; }
#sidebar:not(.open){ transform: translateX(-100%) !important; }

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <link href="./assets/css/app.css" rel="stylesheet"/> <style id="workarea-style">
  :root{
    --workarea-width: 10000px;
    --workarea-height: 10000px;
  }
  #workspace{ position: relative; }
  /* Contenedor de l√≠mites del √°rea de trabajo */
  #workareaBounds{ display:none;
    position: absolute;
    left: 0; top: 0;
    width: var(--workarea-width);
    height: var(--workarea-height);
    
    box-sizing: border-box;
    pointer-events: none;
    z-index: 0; /* por debajo de nodos/cables */
  }
  /* Grid suave opcional dentro del l√≠mite (visual, no molesta) */
  

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="immersive-style">
  html, body { margin:0; padding:0; height:100%; }
  body { background:#000; }
  /* Full-viewport containers (fallbacks for different browsers) */
  body, .app
  .app, .viewport, #workspace {
    width: 100%;
    height: 100dvh;
    min-height: 100svh;
    min-height: 100vh; /* fallback */
    overflow: hidden;
  }
  /* Disable text/image selection and long-press callouts */
  * {
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;
    -webkit-touch-callout: none !important;
  }
  a, img { -webkit-touch-callout: none !important; }
  /* Remove blue tap highlight on Android */
  * { -webkit-tap-highlight-color: transparent; }

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="infinite-canvas-style">
  :root{
    /* Arrancamos con un lienzo grande, pero crecer√° solo */
    --workarea-width: 10000px;
    --workarea-height: 10000px;
    /* Escala visual opcional de bloques (no rompe transforms de tu motor) */
    --node-zoom: 0.90; /* ajusta 0.75‚Äì1.0 seg√∫n prefieras */
  }
  #workspace{
    position: relative;
    /* Grid visual infinito (aunque el l√≠mite crezca) */
    
    
    
  }
  /* L√≠mite visible (se expandir√° autom√°ticamente) */
  #workareaBounds{ display:none;
    position: absolute;
    left: 0; top: 0;
    width: var(--workarea-width);
    height: var(--workarea-height);
    
    box-sizing: border-box;
    pointer-events: none;
    z-index: 0;
  }
  /* Opcional: grid interior m√°s suave dentro del l√≠mite */
  
  /* Downscale visual seguro de bloques: usa zoom (no pisa transform existente) */
  .node, .block {
    zoom: var(--node-zoom);
  }

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="workspace-spec">
  :root{
    --workspace-size: 10000px; /* tama√±o pedido */
  }
  /* Canvas ocupa toda la pantalla debajo del topbar */
  #canvas{
    flex: 1;
    background: #fff;
    position: absolute;
    inset: 46px 0 0 0; /* altura del topbar (ajusta si tu topbar cambia) */
    overflow: hidden;
    touch-action: none;
  }
  /* Workspace es el plano: cuadrado grande escalable, sin l√≠mites visuales */
  #workspace{
    position: absolute;
    top: 0; left: 0;
    width: var(--workspace-size);
    height: var(--workspace-size);
    transform-origin: 0 0;
    background: transparent;
  }

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="surprise-theme">
/* === SORPRESA: Tema "Azul Pro" sin tocar tus bloques (.node) ni el #workspace === */
/* Paleta */
:root{
  --azul-900:#0b1b33;  /* fondo topbar */
  --azul-800:#0f2748;
  --azul-700:#13335f;
  --azul-600:#174178;
  --azul-500:#1c4f92;
  --azul-300:#7fb6ff;  /* resaltes suaves */
  --celeste-100:#ecf5ff; /* backgrounds claros */
  --borde-azul:#0c2c54;
  --sombra: 0 10px 30px rgba(0,0,0,.18);
  --sombra-suave: 0 4px 12px rgba(0,0,0,.12);
}

/* ===== Topbar (contenedor de botones) ===== */
#topbar{
  height: 54px !important;
  backdrop-filter: saturate(1.4) blur(10px);
  background: linear-gradient(180deg, rgba(15,39,72,0.92), rgba(11,27,51,0.92)) !important;
  border-bottom: 1px solid rgba(255,255,255,.08) !important;
  box-shadow: var(--sombra);
}

#topbar button, #burger{
  background: linear-gradient(180deg, #ffffff, #f6f8fb) !important;
  border: 1px solid #c7d2e4 !important;
  color: #0f2748 !important;
  border-radius: 12px !important;
  padding: 8px 12px !important;
  font-weight: 800 !important;
  letter-spacing: .2px;
  box-shadow: 0 2px 0 rgba(0,0,0,.06);
  transition: transform .06s ease, box-shadow .2s ease, background .2s ease;
}
#topbar button:hover, #burger:hover{
  transform: translateY(-1px);
  box-shadow: 0 6px 14px rgba(0,0,0,.12);
}
#topbar button:active, #burger:active{
  transform: translateY(0);
  box-shadow: 0 2px 8px rgba(0,0,0,.12);
}

/* Estados especiales */
#simulate{
  background: linear-gradient(180deg, #e8fff2, #ffffff) !important;
  border-color: #16a34a !important;
}
#simulate.active{
  background: #16a34a !important;
  color: #fff !important;
  border-color:#0f7a36 !important;
}

/* ===== Sidebar / Biblioteca ===== */
#sidebar{
  background: linear-gradient(180deg, var(--azul-700), var(--azul-600)) !important;
  border-right: 3px solid var(--borde-azul) !important;
  color: #eaf2ff !important;
  box-shadow: var(--sombra);
}
#sidebar > div[style*="font-weight"]{
  color:#eaf2ff !important;
  text-shadow: 0 1px 0 rgba(0,0,0,.2);
}

/* Tarjetas de componentes en la biblioteca */
.component{
  background: #f0f7ff !important;       /* celeste claro */
  border: 2px solid #9fbfe9 !important;  /* borde suave */
  color: #0f2748 !important;
  border-radius: 12px !important;
  padding: 10px !important;
  font-size: 20px !important;
  box-shadow: var(--sombra-suave);
  transition: transform .06s ease, box-shadow .2s ease, border-color .2s ease;
}
.component:hover{
  transform: translateY(-1px);
  box-shadow: 0 10px 20px rgba(0,0,0,.14);
  border-color: #6ea5e9 !important;
}
.component.selected{
  outline: 3px solid #60a5fa !important;
  outline-offset: 2px;
}

/* ===== Paleta m√≥vil y otros contenedores de botones ===== */
#fabPalette{
  background: linear-gradient(180deg, #1c4f92, #13335f) !important;
  color:#fff !important;
  border:none !important;
  box-shadow: var(--sombra) !important;
}
#paletteModal{ background: rgba(0,0,0,.45) !important; }
#paletteSheet{
  background: #ffffff !important;
  border-top: 3px solid var(--borde-azul) !important;
  box-shadow: var(--sombra);
}
.pick{
  background: #f0f7ff !important;
  border: 2px solid #bfd3f2 !important;
  color: #0f2748 !important;
  border-radius: 12px !important;
  box-shadow: var(--sombra-suave);
}

/* ===== Men√∫s y tarjetas ===== */
#wireMenu{
  border-color: var(--borde-azul) !important;
  box-shadow: var(--sombra) !important;
}
#wireMenu button:hover{ background: #f2f6ff !important; }

#timerCard{
  background:#ffffff !important;
  border-color: var(--borde-azul) !important;
  box-shadow: var(--sombra) !important;
}
#timerCard h3{ color: var(--azul-700) !important; }
#btnTimerSave{
  background: var(--azul-600) !important;
  border-color: var(--azul-600) !important;
  color:#fff !important;
}

/* ===== Instalaci√≥n PWA & Brand ===== */
#installBtn{
  background: linear-gradient(180deg, #1c4f92, #13335f) !important;
  color:#fff !important;
  border:none !important;
  box-shadow: var(--sombra) !important;
}
#brand{
  background: rgba(12,44,84,.08) !important;
  color: #0f2748 !important;
  border: 1px solid rgba(12,44,84,.12) !important;
}

/* ===== Importante: NO tocar .node ni #workspace ===== */
/* .node { }               <- se mantiene igual (colores de tus bloques) */
/* #workspace { }          <- se mantiene el fondo blanco del √°rea de trabajo */
/* #canvas { }             <- se preserva la zona no trabajable en gris del archivo original */

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="surprise-match-library">
/* === SORPRESA: Topbar minimal y botones con estilo de la Biblioteca === */

/* Caja del topbar: sin fondo, sin borde, sin sombra */
#topbar{
  background: transparent !important;
  border-bottom: none !important;
  box-shadow: none !important;
  height: 54px !important;
  padding: 8px 10px !important;
  gap: 10px !important;
}

/* Botones del topbar con el mismo estilo crom√°tico de la Biblioteca */
#topbar button, #burger{
  background: linear-gradient(180deg, var(--azul-700), var(--azul-600)) !important; /* igual que #sidebar */
  color: #eaf2ff !important;                 /* mismo contraste que textos en sidebar */
  border: 1px solid var(--borde-azul) !important;
  border-radius: 12px !important;
  padding: 10px 14px !important;
  font-weight: 800 !important;
  letter-spacing: .2px;
  box-shadow: var(--sombra) !important;
  transition: transform .06s ease, box-shadow .2s ease, filter .2s ease;
}
#topbar button:hover, #burger:hover{
  transform: translateY(-1px);
  box-shadow: 0 12px 26px rgba(0,0,0,.18) !important;
  filter: saturate(1.05);
}
#topbar button:active, #burger:active{
  transform: translateY(0);
  box-shadow: var(--sombra-suave) !important;
}

/* Mantener "Simular" con feedback verde cuando est√° activo */
#simulate.active{
  background: #16a34a !important;
  color:#fff !important;
  border-color:#0f7a36 !important;
  box-shadow: 0 0 0 2px rgba(22,163,74,.25) inset !important;
}

/* Por seguridad: si quedara alg√∫n estilo residual de +/-, ocultarlo */
#zoomOut, #zoomIn{ display:none !important; }

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="remove-black-stripe">
/* Remove any black stripe above buttons */
#brand {
  display: none !important;
}
#topbar {
  border-top: none !important;
}
body {
  background-color: #ffffff !important;
}

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="pressed-feedback-buttons">
/* === Feedback al presionar botones (sin tocar #simulate) === */
/* Estado normal ya est√° definido por el tema que iguala a la biblioteca. */
/* Estado PRESIONADO: oscurece un poco, reduce sombra y hace un micro-tap */
#topbar button:active:not(#simulate),
#topbar button.pressed:not(#simulate),
#burger:active,
#burger.pressed{
  background: linear-gradient(180deg, var(--azul-800), var(--azul-700)) !important;
  box-shadow: 0 3px 10px rgba(0,0,0,.16) !important;
  transform: translateY(1px) scale(0.98) !important;
}

/* Focus visible para accesibilidad por teclado */
#topbar button:focus-visible, #burger:focus-visible{
  outline: 3px solid #60a5fa !important;
  outline-offset: 2px;
  box-shadow: 0 0 0 3px rgba(96,165,250,.35) !important;
}

/* Mantener comportamiento original de #simulate (sin cambios) */
#simulate:active, #simulate.pressed{ /* sin efecto especial extra */ }

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <script id="pressed-feedback-js">
// A√±ade y quita clase 'pressed' para soportar pantallas t√°ctiles y teclado.
// Excluye #simulate para mantener su comportamiento original.
(function(){
  try{
    var buttons = Array.from(document.querySelectorAll('#topbar button, #burger'))
      .filter(function(b){ return b && b.id !== 'simulate'; });
    buttons.forEach(function(btn){
      function add(){ btn.classList.add('pressed'); }
      function remove(){ btn.classList.remove('pressed'); }
      btn.addEventListener('pointerdown', add);
      btn.addEventListener('pointerup', remove);
      btn.addEventListener('pointerleave', remove);
      btn.addEventListener('pointercancel', remove);
      btn.addEventListener('blur', remove);
      btn.addEventListener('keydown', function(e){
        if(e.key === ' ' || e.key === 'Enter'){ add(); }
      });
      btn.addEventListener('keyup', remove);
    });
  }catch(e){ /* silencioso */ }
})();
</script> <style id="thicker-selected-outline">
/* Aumentar grosor y brillo del borde al seleccionar un bloque */
.node.selected {
    box-shadow: 0 0 0 5px rgba(100,181,246,0.9), 0 12px 32px rgba(13,71,161,0.4) !important;
    border-color: #64b5f6 !important;
}

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="theme-selective">
  /* === THEME SELECTIVE: solo biblioteca, bloques, botones y √°rea NO trabajable === */
  :root{
    --azul-primario: #0E47A1;
    --azul-primario-osc: #0B3A83;
    --azul-primario-claro: #2D66C5;
    --azul-primario-10: rgba(14,71,161,0.10);
    --texto-sobre-azul: #ffffff;
  }
  /* Biblioteca */
  #sidebar{
    background: var(--azul-primario) !important;
    color: var(--texto-sobre-azul) !important;
    border-right: 3px solid var(--azul-primario-osc) !important;
  }
  #sidebar > div[style*="font-weight"]{ color: var(--texto-sobre-azul) !important; }
  /* Bloques insertados */
  .node{
    background: var(--azul-primario-claro) !important;
    border-color: var(--azul-primario-osc) !important;
    color: #0b1b36 !important;
  }
  /* Botones del topbar */
  #topbar button, #burger{
    background: var(--azul-primario) !important;
    color: var(--texto-sobre-azul) !important;
    border: 1px solid var(--azul-primario-osc) !important;
    border-radius: 10px !important;
    box-shadow: 0 2px 0 rgba(0,0,0,.06);
  }
  #topbar button:hover, #burger:hover{ filter: brightness(0.95); }
  #topbar button:active, #burger:active{ transform: translateY(1px); }
  /* Fondo del √°rea NO trabajable (fuera del workspace) */
  #canvas{ background: var(--azul-primario-10) !important; }

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="modern-blocks-v1">
/* ===== BLOQUES MODERNOS ‚Äî "NeoGlass Azul" =====
   - No rompe tu l√≥gica ni JS (solo estilos y un data-atributo)
   - Mantiene tama√±o de bloque (150x225)
   - Inspirado en HMI/PLC modernos: vidrio, luz, micro-relieve
*/
:root{
  --mod-azul:#0E47A1;
  --mod-azul-osc:#0B3A83;
  --mod-azul-claro:#2D66C5;
  --mod-glass:#ffffff;
  --mod-borde: rgba(255,255,255,.55);
  --mod-sombra: 0 18px 50px rgba(14,71,161,.22);
  --mod-sombra-suave: 0 8px 20px rgba(14,71,161,.18);
  --mod-glow: 0 0 24px rgba(0,255,102,.45);
}

/* ----- CARD del bloque ----- */
.node{
  border-radius: 20px !important;
  background: radial-gradient(120% 140% at 20% 0%,
              rgba(255,255,255,.92) 0%, rgba(240,247,255,.92) 45%,
              rgba(229,240,255,.96) 100%) !important;
  border: 2px solid rgba(14,71,161,.20) !important;
  box-shadow: 0 10px 24px rgba(13,71,161,.12), var(--mod-sombra) !important;
  backdrop-filter: saturate(1.1) blur(2px);
  transform: translateZ(0);
  transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease;
}

/* Brillo oblicuo tipo vidrio */
.node::before{
  content:"";
  position:absolute; inset:0;
  border-radius: 20px;
  background: linear-gradient(140deg, rgba(255,255,255,.55), transparent 35%, transparent 65%, rgba(255,255,255,.18));
  pointer-events:none;
}

/* Header sutil con el c√≥digo/etiqueta */
.node::after{
  content:"";
  position:absolute; left:10px; right:10px; top:10px; height:36px;
  border-radius: 14px;
  background: linear-gradient(180deg, rgba(14,71,161,.14), rgba(14,71,161,.06));
  border:1px solid rgba(14,71,161,.20);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.5);
  pointer-events:none;
}

.node:hover{ transform: translateY(-2px); box-shadow: var(--mod-sombra), 0 20px 40px rgba(0,0,0,.14); }
.node.selected{
  box-shadow: 0 0 0 6px rgba(45,102,197,0.28), 0 18px 48px rgba(13,71,161,0.45) !important;
  border-color: rgba(45,102,197,.65) !important;
}

/* ----- Etiqueta principal (s√≠mbolo o I/Q/M) ----- */
.label{
  position: relative;
  z-index: 2;
  margin-top: 30px !important; /* despegar del header */
  font-size: 56px !important;
  letter-spacing: .5px;
  color: #0d1b36 !important;
  text-shadow: 0 1px 0 rgba(255,255,255,.7);
}

/* Badge (B001‚Ä¶) modernizado */
.badge{
  z-index: 3;
  top: 14px !important; left: 14px !important;
  padding: 6px 12px !important;
  border-radius: 999px !important;
  border: 1px solid rgba(14,71,161,.25) !important;
  background: linear-gradient(180deg, #fff, #f6f9ff) !important;
  color: var(--mod-azul) !important;
  box-shadow: 0 3px 0 rgba(0,0,0,.06), 0 10px 20px rgba(13,71,161,.12) !important;
  font-size: 16px !important;
}

/* Indicador Q como LED */
.q-indicator{
  width: 16px !important; height: 16px !important;
  margin-top: 8px !important;
  border-radius: 6px !important;
  border: 2px solid rgba(0,0,0,.35) !important;
  background: linear-gradient(180deg, #9aa4af, #6b7280) !important;
  box-shadow: inset 0 2px 3px rgba(0,0,0,.25) !important;
}
.q-indicator.on{
  background: linear-gradient(180deg, #7cffb1, #00ff66) !important;
  box-shadow: var(--mod-glow), inset 0 2px 3px rgba(0,0,0,.18) !important;
  border-color: #0a6a35 !important;
}

/* ----- Pines (entradas/salidas) ----- */
.terminal{ height: 42px !important; }
.terminal::before{
  height: 12px !important;
  border-radius: 8px !important;
  background: linear-gradient(180deg, #16233b, #0b1426) !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.2), 0 1px 0 rgba(0,0,0,.25);
}
.terminal.pin-selected::before{
  background: linear-gradient(180deg, var(--mod-azul-claro), var(--mod-azul)) !important;
  box-shadow: 0 0 0 4px rgba(45,102,197,.33) !important;
}
.terminal.pin-target{ outline: 3px solid rgba(45,102,197,.45) !important; outline-offset: 2px; }
.terminal.signal-on::before{
  background: linear-gradient(180deg, #7cffb1, #00ff66) !important;
  filter: drop-shadow(0 0 10px rgba(0,255,102,.35));
}

/* Salida redonda (NOT/NAND/NOR) con estilo pulsador */
.terminal.output.out-round{ width: 44px !important; right: calc(-44px) !important; }
.terminal.output.out-round::before{
  width: 44px !important; height: 44px !important; border-radius: 50% !important;
  background: radial-gradient(circle at 30% 30%, #1c2b4a, #0c1733 70%);
  border: 2px solid rgba(12,23,51,.6);
  box-shadow: inset 0 8px 12px rgba(255,255,255,.06), 0 8px 16px rgba(0,0,0,.35);
}
.terminal.output.out-round.signal-on::before{
  background: radial-gradient(circle at 30% 30%, #7cffb1, #00ff66 70%);
  border-color: #0a6a35;
  box-shadow: var(--mod-glow), inset 0 8px 12px rgba(255,255,255,.10);
}

/* ----- Cables y puntos (mejor contraste sin cambiar tu l√≥gica) ----- */
.wire-path{ stroke-linecap: round; }
.wire-path.selected{ stroke: var(--mod-azul-claro) !important; stroke-width: 6 !important; }
.hub-dot{ stroke: var(--mod-azul) !important; fill: var(--mod-azul) !important; }
.hub-dot.signal{ stroke: #00ff66 !important; fill: #00ff66 !important; filter: drop-shadow(0 0 8px rgba(0,255,102,.55)); }

/* ----- Etiquetas de conexi√≥n (conn-tag) estilo chip ----- */
.conn-tag{
  padding: 8px 14px !important;
  border-radius: 999px !important;
  border: 2px solid var(--mod-azul) !important;
  color: var(--mod-azul) !important;
  background: #fff !important;
  box-shadow: 0 8px 18px rgba(13,71,161,.18) !important;
  font-weight: 900 !important;
  letter-spacing: .4px;
}
.conn-tag-src{
  background: linear-gradient(180deg, #1c4f92, #0E47A1) !important;
  color: #fff !important;
  border-color: #0B3A83 !important;
}
.conn-tag.selected{ outline: 4px solid rgba(45,102,197,.35) !important; outline-offset: 2px; }
.conn-tag.signal{
  background: linear-gradient(180deg, #7cffb1, #00ff66) !important;
  color: #012 !important;
  border-color: #0a6a35 !important;
  box-shadow: var(--mod-glow) !important;
}

/* ----- Tipos (opcional): color sutil por tipo sin cambiar tu s√≠mbolo ----- */
.node[data-type="input"]  { border-color: rgba(99,102,241,.35) !important; }
.node[data-type="output"] { border-color: rgba(16,185,129,.40) !important; }
.node[data-type="M"]      { border-color: rgba(234,179,8,.40) !important; }
.node[data-type="ton"],
.node[data-type="toff"]   { border-color: rgba(45,102,197,.45) !important; }
.node[data-type="and"],
.node[data-type="or"],
.node[data-type="not"],
.node[data-type="nand"],
.node[data-type="nor"],
.node[data-type="xor"],
.node[data-type="xnor"],
.node[data-type="sr"]     { border-color: rgba(14,71,161,.35) !important; }


/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="input-not-round-patch">
/* === PATCH: Input NOT pin renders as round black circle (like NOT output) === */
.terminal.input.not{ /* keep default size/position */ }
.terminal.input.not::before{
  width: var(--round-pin) !important;
  height: var(--round-pin) !important;
  border-radius: 50% !important;
  background: #000 !important;
  left: 0 !important;
  right: auto !important;
  box-shadow: none !important;
}
/* Hide the small invert bubble if it was used for NOT indication */
.terminal.input.not::after{
  display: none !important;
}
/* Keep hit area consistent */
.terminal.input.not{ /* keep default size/position */ }

/* === Neon green glow when NOT input is active (signal-on) === */
.terminal.input.not.signal-on::before{
  background: #00ff66 !important; /* neon green */
  box-shadow: 0 0 12px #00ff66, 0 0 24px #00ff66 !important;
  border: none !important;
}

</style> <style id="block-glow-effect">
/* üî• Bloque completo activo con glow y fondo */
.node.has-signal {
  background: linear-gradient(180deg, #e2ffef, #b7ffd5) !important;
  border-color: #00ff66 !important;
  box-shadow: 0 0 18px rgba(0, 255, 102, .6), 0 6px 0 rgba(0, 0, 0, .1) !important;
  
  
}
.node:not(.has-signal) {
  
}
</style> <style id="timer-display-style">
/* === Timer display (TON/TOFF) === */
.timer-display{
  position:absolute;
  bottom:10px;
  left:10px;
  right:10px;
  padding:6px 10px;
  border-radius:10px;
  background: rgba(0,0,0,.06);
  color:#0b1b36;
  font-weight:900;
  font-size:18px;
  text-align:center;
  border:1px solid rgba(0,0,0,.15);
  pointer-events:none;
}
.node.has-signal .timer-display{
  background: rgba(0,255,102,.10);
  border-color: rgba(0,255,102,.35);
  color:#063a1f;
}
</style> <style id="ton-toff-label-reduce">
/* Reduce el tama√±o de la etiqueta SOLO para bloques TON/TOFF */
.node[data-type="ton"] .label,
.node[data-type="toff"] .label{
  font-size: 28px !important;   /* ~50% de 56-60px */
  line-height: 1.05 !important;
}
</style> <style id="badge-title-bigger">
.badge{
  font-size: 24px !important;
}
</style> <style id="logicsoft-two-themes">
/* ====== DOS TEMAS: Original (sin clase) | LOGOSOFT (clase .theme-logosoft en <html>) ====== */

/* LOGOSOFT: bloques crema y workspace blanco */
.theme-logosoft {
  /* variables opcionales si tu CSS ya usa custom props */
  --node: #fff3dd;      /* crema suave para bloque */
  --accent: #d1b38c;    /* borde del bloque dorado claro */
}

/* Mapeo directo sin romper tu CSS existente */
.theme-logosoft .node {
  background: var(--node, #fff3dd) !important;
  border-color: var(--accent, #d1b38c) !important;
}

/* Asegurar workspace BLANCO en este tema */
.theme-logosoft #workspace { background: #ffffff !important; }
/* Si tu canvas contenedor es otro id/clase, descomenta alguno de estos: */
/* .theme-logosoft #canvas { background: #ffffff !important; } */
/* .theme-logosoft .stage  { background: #ffffff !important; } */
</style> <style id="force-workspace-white">
  /* Fuerza fondo blanco del √°rea de trabajo en todos los temas */
  #workspace { background: #ffffff !important; }
</style> <style id="theme-dark">
/* ===== TEMA OSCURO (tercer tema) =====
   - Mantiene #workspace blanco (regla ya forzada aparte).
   - Hace UI, bloques, pines, cables y etiquetas claras/ne√≥n para buen contraste.
*/
.theme-dark {
  --sidebar:#0f172a;   /* slate-900 */
  --node:#111827;      /* gray-900 base del bloque */
  --pin:#e5e7eb;       /* pines claros */
  --wire:#d1d5db;      /* cables claros */
  --neon:#00ff88;      /* ne√≥n ligeramente m√°s c√°lido */
  --accent:#38bdf8;    /* cyan-400 para bordes y acentos */
  --topbar:#0b1220;
  --paper:#0b1220;
  --txt:#e5e7eb;
}

.theme-dark body { background: #0b1220; color: var(--txt); }

/* Topbar y botones */
.theme-dark #topbar{
  background: linear-gradient(180deg, rgba(11,18,32,.92), rgba(11,18,32,.92)) !important;
  border-bottom: 1px solid rgba(255,255,255,.08) !important;
}
.theme-dark #topbar button, .theme-dark #burger{
  background: linear-gradient(180deg, #0f172a, #111827) !important;
  color: var(--txt) !important;
  border: 1px solid rgba(56,189,248,.35) !important;
  border-radius: 12px !important;
  box-shadow: 0 2px 0 rgba(0,0,0,.35) !important;
}

/* Sidebar/biblioteca */
.theme-dark #sidebar{
  background: var(--sidebar) !important;
  border-right: 3px solid rgba(56,189,248,.25) !important;
  color: var(--txt) !important;
}
.theme-dark #sidebar > div[style*="font-weight"]{ color: var(--txt) !important; }

/* √Årea NO trabajable (fuera del workspace) */
.theme-dark #canvas{ background: #0f172a !important; } /* contraste con #workspace blanco */

/* Bloques */
.theme-dark .node{
  background: #111827 !important;
  border-color: var(--accent) !important;
  color: #f8fafc !important;
  box-shadow: 0 10px 24px rgba(2,6,23,.55) !important;
}

/* Etiqueta grande del bloque */
.theme-dark .label{ color: #f8fafc !important; text-shadow: 0 1px 0 rgba(0,0,0,.35); }

/* Pines */
.theme-dark .terminal::before{
  background: var(--pin) !important;
  box-shadow: 0 0 0 2px rgba(2,6,23,.35) inset, 0 1px 0 rgba(0,0,0,.5);
}
.theme-dark .terminal.pin-selected::before{
  background: linear-gradient(180deg, #a5f3fc, #38bdf8) !important;
  box-shadow: 0 0 0 4px rgba(56,189,248,.35) !important;
}
.theme-dark .terminal.pin-target{ outline: 3px solid rgba(56,189,248,.45) !important; outline-offset: 2px; }
.theme-dark .terminal.signal-on::before{
  background: linear-gradient(180deg, #b7ffdf, #00ff88) !important;
  filter: drop-shadow(0 0 10px rgba(0,255,136,.35));
}

/* Salida redonda */
.theme-dark .terminal.output.out-round::before{
  background: radial-gradient(circle at 30% 30%, #d1d5db, #9ca3af 70%) !important;
  border: 2px solid rgba(96,165,250,.4) !important;
}
.theme-dark .terminal.output.out-round.signal-on::before{
  background: radial-gradient(circle at 30% 30%, #b7ffdf, #00ff88 70%) !important;
  border-color: #16a34a !important;
  box-shadow: 0 0 12px rgba(0,255,136,.55) !important;
}

/* Cables y hubs */
.theme-dark .wire-path{ stroke: var(--wire) !important; }
.theme-dark .wire-path.signal{ stroke: var(--neon) !important; filter: drop-shadow(0 0 8px rgba(0,255,136,.35)); }
.theme-dark .wire-path.selected{ stroke: #38bdf8 !important; }
.theme-dark .hub-dot{ fill: #e5e7eb !important; stroke: #e5e7eb !important; }
.theme-dark .hub-dot.signal{ fill: var(--neon) !important; stroke: var(--neon) !important; filter: drop-shadow(0 0 8px rgba(0,255,136,.55)); }

/* Etiquetas */
.theme-dark .conn-tag{
  background: #0f172a !important;
  color: #f0f9ff !important;
  border: 2px solid var(--accent) !important;
  box-shadow: 0 8px 18px rgba(2,6,23,.45) !important;
}
.theme-dark .conn-tag-src{
  background: linear-gradient(180deg, #164e63, #0e7490) !important;
  color: #ecfeff !important;
  border-color: #06b6d4 !important;
}
.theme-dark .conn-tag.selected{ outline: 4px solid rgba(56,189,248,.35) !important; outline-offset: 2px; }
.theme-dark .conn-tag.signal{
  background: linear-gradient(180deg, #b7ffdf, #00ff88) !important;
  color: #002010 !important;
  border-color: #16a34a !important;
  box-shadow: 0 0 16px rgba(0,255,136,.45) !important;
}

/* LED Q */
.theme-dark .q-indicator{
  background: linear-gradient(180deg, #94a3b8, #64748b) !important;
  border-color: rgba(255,255,255,.35) !important;
}
.theme-dark .q-indicator.on{
  background: linear-gradient(180deg, #b7ffdf, #00ff88) !important;
  border-color: #065f46 !important;
  box-shadow: 0 0 10px rgba(0,255,136,.45), inset 0 2px 3px rgba(0,0,0,.18) !important;
}
</style> <style id="force-workspace-white">
  #workspace { background: #ffffff !important; }
</style> <style id="theme-dark-patch">
/* Patch: Dark theme with light blocks and dark workspace */
.theme-dark #workspace { background: #262626 !important; }
.theme-dark .node {
  background: #f3f4f6 !important; /* light block */
  border-color: #38bdf8 !important;
  color: #1f2937 !important;
}
</style> <style id="theme-dark-blocks-update">
/* === Dark theme updated: mid-gray blocks, black text === */
.theme-dark .node {
  background: #bfc4cc !important;
  border-color: #38bdf8 !important;
  color: #000000 !important;
}
.theme-dark .label,
.theme-dark .badge,
.theme-dark .conn-tag {
  color: #000000 !important;
}
.theme-dark .conn-tag {
  background: #bfc4cc !important;
  border-color: #38bdf8 !important;
}
</style> <style id="theme-dark-components-and-active">
/* Sidebar components match block color in dark mode */
.theme-dark .component {
  background: #bfc4cc !important;
  border-color: #38bdf8 !important;
  color: #000000 !important;
  box-shadow: none !important;
}

/* Active blocks during simulation in dark mode */
.theme-dark .node.has-signal {
  border-color: #00ff88 !important;
  box-shadow: 0 0 20px rgba(0, 255, 136, 0.6) !important;
}
</style> <style id="theme-dark-active-bg-and-sim-btn">
/* Active block background in dark mode */
.theme-dark .node.has-signal {
  background: #d1ffe7 !important;  /* soft green hint */
  border-color: #00ff88 !important;
  box-shadow: 0 0 20px rgba(0, 255, 136, 0.6) !important;
  color: #000000 !important;
}

/* Simulate button state indicator */
#simulate.active {
  background: #00ff88 !important;
  color: #000 !important;
  border-color: #00b568 !important;
  box-shadow: 0 0 12px rgba(0, 255, 136, 0.6), 0 2px 0 rgba(0,0,0,0.15) inset !important;
}
</style> <style id="theme-dark-pin-negated">
/* Lighten negated pin circle in dark mode */
.theme-dark .terminal.negated::before,
.theme-dark .terminal.neg-round::before {
  background: #e5e7eb !important; /* light gray */
  border: 2px solid #38bdf8 !important;
  box-shadow: 0 0 4px rgba(255,255,255,0.35);
}
</style> <style id="theme-dark-pin-and-hub">
/* Negation circle on input pin */
.theme-dark .terminal.input.not::after,
.theme-dark .terminal.input.not::before {
  background: #e5e7eb !important; /* light */
  border: 2px solid #38bdf8 !important;
  box-shadow: 0 0 4px rgba(255,255,255,0.35) !important;
}

/* Hub dots on wires */
.theme-dark .hub-dot {
  fill: #e5e7eb !important;
  stroke: #e5e7eb !important;
  filter: drop-shadow(0 0 4px rgba(255,255,255,0.35));
}
.theme-dark .hub-dot.signal {
  fill: #00ff88 !important;
  stroke: #00ff88 !important;
}
</style> .theme-dark .node.selected { border-width: 6px !important; border-color: #7dd3fc !important; /* celeste claro */ box-shadow: 0 0 0 4px rgba(125,211,252,0.45), 0 12px 24px rgba(0,0,0,0.4) !important; } /* === Assistant Patch: Selected block styling, F2 (15% celeste background) === */ .theme-dark .node.selected { border-width: 6px !important; border-color: #7dd3fc !important; background: rgba(125, 211, 252, 0.15) !important; /* celeste suave */ box-shadow: 0 0 0 4px rgba(125,211,252,0.40), 0 12px 24px rgba(0,0,0,0.40) !important; } <style id="assistant-strong-selected-block">
html.theme-dark .node.selected {
  background-color: rgba(125, 211, 252, 0.18) !important; /* fondo celeste suave */
  border: 4px solid #7dd3fc !important; /* borde celeste brillante */
  box-shadow: 0 0 14px rgba(125, 211, 252, 0.35), 0 0 4px rgba(255,255,255,0.08) !important;
}
</style> <style id="assistant-neon-blue-selected-block">
html.theme-dark .node.selected {
  background-color: #3b82f6 !important;        /* azul ne√≥n s√≥lido */
  border: 4px solid #60a5fa !important;        /* azul ne√≥n claro */
  box-shadow:
    0 0 12px rgba(59,130,246,0.65),
    0 0 4px rgba(255,255,255,0.15) !important; /* resplandor */
  color: white !important;                     /* texto visible */
}
</style> <style>
/* === Custom: Original theme with Neon Blue Blocks === */
html:not(.theme-dark):not(.theme-logosoft) .node {
  background-color: #3b82f6 !important;  /* Neon blue */
  border-color: #60a5fa !important;
  color: #fff !important;
}


/* === Custom: Stronger Blocks in LogoSoft Theme === */
.theme-logosoft .node {
  background-color: #ffddaa !important; /* Stronger pastel cream */
  border-color: #caa97d !important;
}
</style> <style id="simulate-dark-active-fix">
/* Ensure Simulate button shows active state in dark theme */
html.theme-dark #simulate.active {
  background: #00ff88 !important;
  color: #000 !important;
  border-color: #00b568 !important;
  box-shadow: 0 0 12px rgba(0, 255, 136, 0.6), 0 2px 0 rgba(0,0,0,0.15) inset !important;
}
</style> <style id="logosoft-block-active-fix">
/* Active block highlight in LogoSoft theme */
html.theme-logosoft .node.has-signal {
  background: #d1ffe7 !important;  /* soft green hint */
  border-color: #00ff88 !important;
  box-shadow: 0 0 20px rgba(0, 255, 136, 0.6) !important;
  color: #000000 !important;
}
</style> <style id="io-badge-blue">
  /* Texto en azul para la etiqueta superior de los bloques I y Q */
  .node[data-type="input"]  .io-badge,
  .node[data-type="output"] .io-badge {
    color: #0078d7 !important; /* Azul vivo */
  }

  /* Opcional: tono m√°s claro en modo oscuro */
  html.theme-dark .node[data-type="input"]  .io-badge,
  html.theme-dark .node[data-type="output"] .io-badge {
    color: #60a5fa !important;
  }
</style> <style id="io-badge-blue-dark">
  /* Azul m√°s oscuro para la etiqueta IO en modo oscuro */
  html.theme-dark .node[data-type="input"]  .io-badge,
  html.theme-dark .node[data-type="output"] .io-badge {
    color: #1e40af !important; /* Azul oscuro */
  }
</style> <style id="dark-workspace-bg">
  /* Fondo oscuro del √°rea de trabajo en modo oscuro */
  html.theme-dark body { background: #0b0f14 !important; }
  html.theme-dark #canvas { background: #0b0f14 !important; }      /* zona no trabajable */
  html.theme-dark #workspace { background: #0f141b !important; }   /* √°rea trabajable */
  /* Si hubiera l√≠neas de gu√≠a o bordes, b√°jalas un poco */
  html.theme-dark #workspace, html.theme-dark #canvas {
    color: #e6edf3 !important;
  }
</style> <style id="perf-optimizations">
  /* Aislar pintura y composici√≥n de las capas principales */
  #canvas, #workspace { contain: layout paint style; }
  #workspace { transform: translateZ(0); backface-visibility: hidden; }
  /* Promover cada bloque a capa de GPU y avisar del posible cambio */
  .node { will-change: transform, left, top; transform: translateZ(0); }
  /* Mientras arrastras: quita sombras/transiciones costosas */
  body.dragging .node { box-shadow: none !important; filter: none !important; transition: none !important; }
  /* Tambi√©n en modo rendimiento forzado */
  body.perf-lite .node { box-shadow: none !important; filter: none !important; }
  /* Cables: sin sombras/bordes caros */
  .wire, .cable, .connection {
    box-shadow: none !important;
    border-radius: 0 !important;
  }
  /* Cursor suave durante drag para evitar repaints extra */
  body.dragging { cursor: grabbing !important; }
</style> <style id="anti-flicker-styles">
  /* Desactiva el brillo visual original en outputs para evitar parpadeo */
  .node[data-type="output"].has-signal {
    /* neutraliza efectos visuales si los hubiese */
    box-shadow: none !important;
    filter: none !important;
  }
  /* Capa visual estable controlada por la IA */
  .node[data-type="output"].ui-on {
    outline: 3px solid var(--neon, #00ff66) !important;
    outline-offset: 2px !important;
    background: rgba(0,255,136,0.15) !important;
    box-shadow: 0 0 16px rgba(0,255,136,0.45) !important;
  }
  /* En tema oscuro, un poco m√°s intenso */
  html.theme-dark .node[data-type="output"].ui-on {
    background: rgba(0,255,136,0.22) !important;
    box-shadow: 0 0 20px rgba(0,255,136,0.55) !important;
  }
</style> <style id="active-green-all-themes">
  /* === Active block (has-signal / ui-on) ‚Äî ALL THEMES === */

  /* Original theme (no class) */
  html:not(.theme-dark):not(.theme-logosoft) .node.has-signal,
  html:not(.theme-dark):not(.theme-logosoft) .node.ui-on {
    background: rgba(0, 255, 136, 0.20) !important;
    box-shadow: 0 0 20px rgba(0, 255, 136, 0.50) !important;
    border-color: #00ff88 !important;
    outline: none !important; filter: none !important;
  }

  /* LogoSoft theme */
  html.theme-logosoft .node.has-signal,
  html.theme-logosoft .node.ui-on {
    background: #d1ffe7 !important;
    box-shadow: 0 0 20px rgba(0, 255, 136, 0.60) !important;
    border-color: #00ff88 !important;
    outline: none !important; filter: none !important;
  }

  /* Dark theme */
  html.theme-dark .node.has-signal,
  html.theme-dark .node.ui-on {
    background: rgba(0, 255, 136, 0.30) !important;
    box-shadow: 0 0 24px rgba(0, 255, 136, 0.65) !important;
    border-color: #00ff88 !important;
    outline: none !important; filter: none !important;
  }
</style> <style id="borders-and-active-glow-patch">
  /* Inactive blocks: constant blue border */
  .node:not(.has-signal):not(.ui-on) {
    border: 3px solid #2196f3 !important;
    outline: none !important;
    box-shadow: none !important;
  }
  /* Active blocks: green border + glow (keep your background hint) */
  .node.has-signal, .node.ui-on {
    border: 2px solid #00ff88 !important;
    box-shadow: 0 0 24px rgba(0, 255, 136, 0.65) !important;
    outline: none !important;
    filter: none !important;
  }
</style> <style id="selection-and-dark-active-clarity">
  /* 1) Cambio de color al seleccionar el bloque (sin simulaci√≥n activa) */
  .node.selected:not(.has-signal):not(.ui-on) {
    background: rgba(33, 150, 243, 0.14) !important;    /* tinte azul suave */
    box-shadow: 0 0 0 2px #2196f3 inset !important;      /* borde interno de selecci√≥n */
    outline: none !important;
  }

  /* 2) En modo oscuro: activaci√≥n con verde m√°s visible y sin mezcla con el fondo */
  html.theme-dark .node.has-signal,
  html.theme-dark .node.ui-on {
    background: rgba(0, 255, 136, 0.48) !important;      /* m√°s opaco para que no se confunda con el fondo */
    mix-blend-mode: normal !important;                    /* evita mezclas con el fondo oscuro */
    filter: none !important;                              /* sin filtros que apaguen el color */
  }

  /* Mantener el borde verde cuando est√° activo en cualquier tema */
  .node.has-signal, .node.ui-on {
    border: 2px solid #00ff88 !important;
  }
</style> <style id="selection-border-5px-and-brighter-dark-active">
  /* Selecci√≥n con borde azul m√°s grueso */
  .node.selected:not(.has-signal):not(.ui-on){
    background: rgba(33, 150, 243, 0.14) !important;
    box-shadow: 0 0 0 5px #2196f3 inset !important; /* borde interno m√°s grueso */
    outline: none !important;
  }

  /* Modo oscuro: activado con verde m√°s claro y visible */
  html.theme-dark .node.has-signal,
  html.theme-dark .node.ui-on{
    background: rgba(0, 255, 136, 0.75) !important; /* m√°s opaco y brillante */
    mix-blend-mode: normal !important;
    filter: none !important;
  }
</style> <style id="q-only-lighten-strong">
/* Fuerza a que Q no herede capas/oscuridad cuando est√° activo en modo oscuro */
html.theme-dark .node[data-type="output"].has-signal,
:root.dark .node[data-type="output"].has-signal {
  background: #d1ffe7 !important;
  color: #000 !important;
  box-shadow: 0 0 24px rgba(0,255,136,.75) !important;
  filter: none !important;
  -webkit-filter: none !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  mix-blend-mode: normal !important;
  background-image: none !important;
}

/* Quitar/neutralizar overlays que podr√≠an oscurecer (antes/despu√©s) */
html.theme-dark .node[data-type="output"].has-signal::before,
html.theme-dark .node[data-type="output"].has-signal::after,
:root.dark .node[data-type="output"].has-signal::before,
:root.dark .node[data-type="output"].has-signal::after {
  opacity: 0 !important;
  box-shadow: none !important;
  background: transparent !important;
  mix-blend-mode: normal !important;
}

/* Si existe una capa interna de ‚Äúvidrio‚Äù o ‚Äúsombra‚Äù dentro del bloque Q */
html.theme-dark .node[data-type="output"].has-signal .glass,
html.theme-dark .node[data-type="output"].has-signal .overlay,
html.theme-dark .node[data-type="output"].has-signal .shade,
html.theme-dark .node[data-type="output"].has-signal .gradient,
html.theme-dark .node[data-type="output"].has-signal .panel,
html.theme-dark .node[data-type="output"].has-signal .shine,
:root.dark .node[data-type="output"].has-signal .glass,
:root.dark .node[data-type="output"].has-signal .overlay,
:root.dark .node[data-type="output"].has-signal .shade,
:root.dark .node[data-type="output"].has-signal .gradient,
:root.dark .node[data-type="output"].has-signal .panel,
:root.dark .node[data-type="output"].has-signal .shine {
  opacity: 0 !important;
  filter: none !important;
  mix-blend-mode: normal !important;
}

/* Aclara la barra superior/placa si existe */
html.theme-dark .node[data-type="output"].has-signal .label,
html.theme-dark .node[data-type="output"].has-signal .header,
html.theme-dark .node[data-type="output"].has-signal .titlebar,
:root.dark .node[data-type="output"].has-signal .label,
:root.dark .node[data-type="output"].has-signal .header,
:root.dark .node[data-type="output"].has-signal .titlebar {
  color: #000 !important;
  background: rgba(255,255,255,.35) !important;
}
</style> <style id="tiny-polish-pack">
/* === Cambios m√≠nimos sobre TU DISE√ëO ACTUAL === */
/* 1) Modo oscuro: los bloques ACTIVOS usan el mismo degradado del tema original */
html.theme-dark .node.has-signal {
  background: linear-gradient(180deg, #e2ffef, #b7ffd5) !important;
  border-color: #00ff88 !important;
  box-shadow: 0 0 18px rgba(0,255,136,.6), 0 6px 0 rgba(0,0,0,.10) !important;
  color: #001b10 !important;
  mix-blend-mode: normal !important;
  filter: none !important;
  background-image: linear-gradient(180deg, #e2ffef, #b7ffd5) !important;
}
/* 1.1) Si el bloque est√° seleccionado Y activo, mantener el mismo look (no oscurecer) */
html.theme-dark .node.selected.has-signal {
  background: linear-gradient(180deg, #e2ffef, #b7ffd5) !important;
  border-color: #00ff88 !important;
  box-shadow: 0 0 22px rgba(0,255,136,.65), 0 0 0 3px rgba(125,211,252,.35) !important;
  color: #001b10 !important;
}

/* 2) Badge/etiquetas: contraste claro cuando el bloque est√© activo en modo oscuro */
html.theme-dark .node.has-signal .badge,
html.theme-dark .node.has-signal .label {
  color: #001b10 !important;
}

/* 3) Cables con se√±al un poquito m√°s visibles en modo oscuro (sin cambiar color) */
html.theme-dark .wire-path.signal {
  stroke-width: 6 !important;
}

/* 4) Quitar overlays que oscurecen cuando el bloque est√° activo */
html.theme-dark .node.has-signal::before,
html.theme-dark .node.has-signal::after {
  opacity: 0 !important;
  background: transparent !important;
  box-shadow: none !important;
  mix-blend-mode: normal !important;
}

/* 5) Accesibilidad: foco visible al navegar con teclado en bloques */
.node:focus-visible {
  outline: 3px solid #60a5fa !important;
  outline-offset: 2px;
}

/* (No se tocan pines, ni cables en reposo, ni la l√≥gica del scan) */
</style> <style id="pwa-fix-style">
  /* Evita gestos del navegador que cancelen el drag/insert */
  #canvas, #workspace, .component, .node, .terminal {
    touch-action: none;
    -webkit-user-drag: none;
  }
</style> <style id="logicsoft-mobile-fix">
/* Ajuste fuerte para m√≥viles: botones y bloques m√°s peque√±os */
@media (max-width: 900px) {
  html{
    -webkit-text-size-adjust: 100% !important;
    text-size-adjust: 100% !important;
    font-size: 14px !important;
  }

  /* Topbar buttons */
  #topbar button,
  #burger{
    font-size: 13px !important;
    padding: 4px 8px !important;
    border-radius: 10px !important;
    min-width: auto !important;
  }

  /* Paleta lateral */
  #sidebar{
    width: 150px !important;
  }
  #sidebar .component,
  .component{
    font-size: 14px !important;
    padding: 6px 8px !important;
    border-radius: 10px !important;
  }

  /* Bloques en el workspace un poco m√°s compactos */
  .node{
    transform: scale(0.9) !important;
    transform-origin: center center !important;
  }
}
</style> <style id="logicsoft-topbar-fix">
@media (max-width: 900px){

  /* Topbar m√°s compacto */
  #topbar{
    padding: 4px 6px !important;
    gap: 6px !important;
    flex-wrap: wrap !important;
    justify-content: flex-start !important;
  }

  /* Botones de la barra superior */
  #topbar button,
  #burger{
    font-size: 11px !important;
    padding: 3px 6px !important;
    height: 32px !important;
    min-width: 85px !important;
    border-radius: 8px !important;
  }

  /* Iconos dentro de los botones */
  #topbar button svg,
  #burger svg{
    width: 14px !important;
    height: 14px !important;
  }

  /* Contenedores del toolbar m√°s ajustados */
  .toolbar-wrapper, .toolbar, #toolbar{
    padding: 0 !important;
    margin: 0 !important;
    gap: 4px !important;
  }

  /* Sidebar compacto */
  #sidebar{
    width: 130px !important;
  }
  #sidebar .component,
  .component{
    font-size: 13px !important;
    padding: 6px !important;
  }
}
</style> <style id="logicsoft-premium-locked">
  /* Bloques premium visibles pero bloqueados en versi√≥n b√°sica (sidebar) */
  .component[data-premium="1"]{
    position: relative;
    opacity: .45;
    border-style: dashed;
    cursor: not-allowed;
  }
  .component[data-premium="1"]::after{
    content: "üîí";
    position: absolute;
    top: 4px;
    right: 6px;
    font-size: 14px;
  }

  /* Cuando el dispositivo est√° en FULL, se ven normales */
  body.full-mode .component[data-premium="1"]{
    opacity: 1;
    border-style: solid;
    cursor: grab;
  }
  body.full-mode .component[data-premium="1"]::after{
    content: "";
  }

  /* Paleta m√≥vil: mismo efecto */
  #paletteGrid .pick[data-premium="1"]{
    position: relative;
    opacity:.45;
    border-style:dashed;
    cursor:not-allowed;
  }
  #paletteGrid .pick[data-premium="1"]::after{
    content:"üîí";
    position:absolute;
    top:4px;
    right:6px;
    font-size:14px;
  }
  body.full-mode #paletteGrid .pick[data-premium="1"]{
    opacity:1;
    border-style:solid;
    cursor:pointer;
  }
  body.full-mode #paletteGrid .pick[data-premium="1"]::after{
    content:"";
  }

  @keyframes premiumShake{
    0%,100% { transform: translateX(0); }
    20% { transform: translateX(-2px); }
    40% { transform: translateX(2px); }
    60% { transform: translateX(-2px); }
    80% { transform: translateX(2px); }
  }
  .component.shake-premium{
    animation: premiumShake .25s linear;
  }
</style> </head> <body> <script>
  (function(){
    const LOCAL_KEY_FULL = "logicsoft_full_v1";
    function syncFullModeClass(){
      let full = false;
      try {
        full = localStorage.getItem(LOCAL_KEY_FULL) === "1";
      } catch(e){
        full = !!window.isFull;
      }
      document.body.classList.toggle("full-mode", !!full);
      window.isFull = !!full;
    }
    window.syncFullModeClass = syncFullModeClass;
    if (document.readyState === "loading"){
      document.addEventListener("DOMContentLoaded", syncFullModeClass, {once:true});
    } else {
      syncFullModeClass();
    }
  })();
</script> <div id="splashOverlay" aria-hidden="true" style="display:none"> <div id="splashCard"> <div id="splashTitle">LOGICSOFT</div> <div id="splashSubtitle">Toca <b>Nuevo</b> para iniciar el dise√±o</div> </div> </div> <div id="topbar"> <button id="themeBtnTwo" title="Tema: Original" aria-label="Tema: Original" style="width:36px;height:36px;border-radius:50%;display:inline-flex;align-items:center;justify-content:center; font-size:16px;border:1px solid #777;background:#fff;cursor:pointer;margin-left:6px">üé®</button> <button id="burger">‚ò∞</button> <button id="btnSave"><svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M17 3H5v18h14V7zM12 17l-4-4h3V9h2v4h3z"/></svg> Guardar</button> <button id="btnLoad"><svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M19 13v6H5v-6H3v6a2 2 0 002 2h14a2 2 0 002-2v-6zM12 16l4-4h-3V4h-2v8H8z"/></svg> Importar</button> <button id="btnNew"><svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M13 11h8v2h-8v8h-2v-8H3v-2h8V3h2z"/></svg> Nuevo</button> <input accept="application/json" id="loadInput" style="display:none" type="file"/> <div id="spacer"></div> <button id="simulate"><svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M8 5v14l11-7z"/></svg> Simular</button> <button id="stop"><svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M6 6h12v12H6z"/></svg> Detener</button> <button id="deleteBtn"><svg width="18" height="18" viewBox="0 0 24 24"><path d="M16 9v10H8V9h8m-1.5-6h-5l-1 1H5v2h14V4h-4.5l-1-1z" /></svg>Eliminar</button> <button id="btnEdit"><svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 000-1.41l-2.34-2.34a.996.996 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg> Editar</button> </div> <div id="sidebar"> <div style="font-weight:900; font-size:24px; margin:14px 0 12px 0; text-align:center; color:#fff; text-shadow:0 1px 2px rgba(0,0,0,.4)">LOGICSOFT</div> <div class="component" data-type="input" draggable="true">Entrada (I)</div> <div class="component" data-type="output" draggable="true">Salida (Q)</div> <div class="component" data-type="M" draggable="true">Memoria (M)</div> <div style="height:4px"></div> <div class="component" data-type="and" draggable="true">AND</div> <div class="component" data-type="or" draggable="true">OR</div> <div class="component" data-type="not" draggable="true">NOT</div> <div class="component" data-type="nand" draggable="true">NAND</div> <div class="component" data-type="nor" draggable="true">NOR</div> <div class="component" data-type="xor" draggable="true">XOR</div> <div class="component" data-type="xnor" draggable="true">XNOR</div> <div class="component" data-type="sr" data-premium="1" draggable="true">SR</div> <div class="component" data-type="ton" data-premium="1" draggable="true">TON</div> <div class="component" data-type="toff" data-premium="1" draggable="true">TOFF</div> <div style="height:4px"></div> <div style="flex:1"></div> <div style="font-size:11px;color:#333">Arrastra un bloque al √°rea.</div> </div> <div id="canvas"> <div id="workspace"> <svg height="5000" id="wires" preserveaspectratio="none" viewbox="0 0 5000 5000" width="5000" xmlns="http://www.w3.org/2000/svg"></svg> </div> </div> <button id="btnSoporte" class="btn-soporte">DESBLOQUEA TON, TOFF Y SR</button> <div id="brand">LOGICSOFT</div> <button id="installBtn">Instalar LOGICSOFT</button> <button id="fabPalette">üß© Bloques</button> <div aria-hidden="true" id="paletteModal"> <div id="paletteSheet"> <div style="font-weight:900;margin-bottom:10px;color:#003366">Elige un bloque</div> <div id="paletteGrid"></div> <div style="margin-top:10px;display:flex;justify-content:center"> <button id="closePalette" style="padding:8px 12px;border-radius:8px;border:1px solid #777;background:#fff;font-weight:700">Cerrar</button> </div> </div> </div> <div id="wireMenu"> <button id="menuAddNode">‚ûï Crear nodo para acomodar</button> <button id="menuMakeLabel">üè∑Ô∏è Crear etiqueta y eliminar cable</button> </div> <div id="tagMenu" style="position:fixed;z-index:240;display:none;background:#fff;border:2px solid #003366;border-radius:12px;box-shadow:0 10px 24px rgba(0,0,0,.18);overflow:hidden"> <button id="tagDelete" style="display:block;width:100%;background:#fff;border:0;border-bottom:1px solid #e5e5e5;padding:10px 14px;font-weight:800;cursor:pointer;text-align:left">üóëÔ∏è Eliminar etiqueta</button> <button id="tagRevert" style="display:block;width:100%;background:#fff;border:0;padding:10px 14px;font-weight:800;cursor:pointer;text-align:left">üîÅ Revertir a cable</button> </div> <div id="timerModal"> <div id="timerCard"> <h3 id="timerTitle">Configurar temporizador</h3> <label for="timerSec">Tiempo (s)</label> <input id="timerSec" min="0" step="0.1" type="number" value="1"/> <div id="timerActions"> <button id="btnTimerCancel">Cancelar</button> <button id="btnTimerSave">Guardar</button> </div> </div> </div> <script>
const NODE_W = 150; // ancho de bloque .node
const NODE_H = 225; // alto de bloque .node

/* ===== PWA b√°sico ===== */
let deferredPrompt=null;
const installBtn=document.getElementById('installBtn');
window.addEventListener('beforeinstallprompt',(e)=>{ e.preventDefault(); deferredPrompt=e; installBtn.style.display='block'; });
installBtn.addEventListener('click', async()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); await deferredPrompt.userChoice; installBtn.style.display='none'; deferredPrompt=null; });
if('serviceWorker' in navigator){ window.addEventListener('load',()=>{ navigator.serviceWorker.register('./service-worker.js').catch(console.error); }); }

/* ===== SIMUPASIR ===== */
const burger = document.getElementById('burger');
const sidebar = document.getElementById('sidebar');
burger.setAttribute('aria-controls', 'sidebar');
burger.setAttribute('aria-expanded', String(sidebar.classList.contains('open')));
burger.addEventListener('click', ()=>{
  const isOpen = sidebar.classList.toggle('open');
  burger.setAttribute('aria-expanded', String(isOpen));
});
const canvas = document.getElementById("canvas");
const workspace = document.getElementById("workspace");
const wiresSVG = document.getElementById("wires");
function disableWireHits() {
  try {
    if (wiresSVG) wiresSVG.style.pointerEvents = 'none';
    document.querySelectorAll('.conn-tag,.bend-hit,.hub-hit,.wire-hit').forEach(el => el.style.pointerEvents = 'none');
  } catch(e) {}
}
function enableWireHits() {
  try {
    if (wiresSVG) wiresSVG.style.pointerEvents = 'auto';
    document.querySelectorAll('.conn-tag,.bend-hit,.hub-hit,.wire-hit').forEach(el => el.style.pointerEvents = 'auto');
  } catch(e) {}
}

const components = document.querySelectorAll(".component");
const btnSave = document.getElementById('btnSave');
const btnLoad = document.getElementById('btnLoad');
const loadInput = document.getElementById('loadInput');
const deleteBtn = document.getElementById('deleteBtn');

let nodes=[], connections=[], pendingOutput=null, pendingGhost=null;
let simulation=false;
let inputCount=0, outputCount=0, memoryCount=0;
let blockCodeCount=0;  // B001, B002, ...
let scale=1, panX=0, panY=0, isPanning=false, panStartX=0, panStartY=0;
let simTimer=null, SCAN_MS=60;
let selectedNode=null, selectedConn=null;
let selectedTag=null;
let selectedBranch=null; // para ramas de etiquetas
let draggingBend=null;
let longPressTimer=null;
let currentToPlace=null;
let selectedPinEl=null;

/* Hubs (juntas) por pin de salida */
const outputHubs = new WeakMap(); // pinEl -> { x,y, dot, hit, stemPath, branches:Set }

/* ==== Temporizador Modal (segundos) ==== */
const timerModal = document.getElementById('timerModal');
const timerTitle = document.getElementById('timerTitle');
const timerSecInput = document.getElementById('timerSec');
const btnTimerCancel = document.getElementById('btnTimerCancel');
const btnTimerSave = document.getElementById('btnTimerSave');
let timerNode=null;

function openTimerModal(node){
  timerNode = node;
  const kind = node.type.toUpperCase();
  const code = node.code || node.name;
  timerTitle.textContent = `Configurar ${kind} (${code})`;
  const sec = Math.max(0, Math.round(((node.delayMs ?? 1000)/1000)*10)/10);
  timerSecInput.value = sec;
  timerModal.style.display='block';
}
function closeTimerModal(){
  timerModal.style.display='none';
  timerNode=null;
}
btnTimerCancel.addEventListener('click', closeTimerModal);
btnTimerSave.addEventListener('click', ()=>{
  if(!timerNode) return;
  let sec = parseFloat(timerSecInput.value);
  if(isNaN(sec)||sec<0) sec=0;
  timerNode.delayMs = Math.round(sec*1000);
  // reset de estado interno del temporizador
  timerNode.timerStart=null;
  timerNode.seenHigh=false;   // para TOFF
  timerNode.prevIn=0;
  // update UI label on the node
  try{
    const disp = timerNode && timerNode.el && timerNode.el.querySelector('.timer-display');
    if(disp){
      const secLab = Math.max(0, Math.round(((timerNode.delayMs ?? 1000)/1000)*10)/10);
      disp.textContent = secLab.toFixed(1) + ' s';
    }
  }catch(e){}
  closeTimerModal();
});
timerModal.addEventListener('click',(e)=>{ if(e.target===timerModal) closeTimerModal(); });

/* ===== Util ===== */
function zpad(n,len=3){ return String(n).padStart(len,'0'); }
function logoLabelForType(type){
  switch(type){
    case 'and':  return '&';
    case 'nand': return '&';
    case 'or':   return '‚â•1';
    case 'nor':  return '‚â•1';
    case 'not':  return '1';
    case 'xor':  return '=1';
    case 'xnor': return '‚â†1';
    case 'sr':   return 'S/R';
    case 'M':    return 'M';
    case 'ton':  return 'TON';
    case 'toff': return 'TOFF';
    default:     return (type||'').toUpperCase();
  }
}
function clientToWorkspace(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  return { x:(clientX-rect.left-panX)/scale, y:(clientY-rect.top-panY)/scale };
}
function terminalEdge(term){
  const rect = term.getBoundingClientRect();
  const wsRect = workspace.getBoundingClientRect();
  const isInput=term.classList.contains('input');
  const isOutput=term.classList.contains('output');
  const xScreen = isInput ? rect.left : (isOutput ? rect.right : rect.left + rect.width/2);
  const yScreen = rect.top + rect.height/2;
  return { x:(xScreen-wsRect.left)/scale, y:(yScreen-wsRect.top)/scale };
}

/* Zoom & Pan */
canvas.addEventListener("wheel", e=>{ e.preventDefault(); setZoom(scale + (e.deltaY>0?-0.08:0.08)); });
function setZoom(next){
  const rect = canvas.getBoundingClientRect();
  const cx = rect.left+rect.width/2, cy = rect.top+rect.height/2;
  const fx=(cx-rect.left-panX)/scale, fy=(cy-rect.top-panY)/scale;
  const newScale = Math.max(.25, Math.min(3,next));
  panX = cx-rect.left - fx*newScale; panY = cy-rect.top - fy*newScale; scale=newScale;
  updateTransform(); updateConnections();
}
function updateTransform(){ workspace.style.transform=`translate(${panX}px,${panY}px) scale(${scale})`; }
workspace.addEventListener("mousedown", e=>{
  if(e.target===workspace){
    if(e.button===0) clearSelection();
    isPanning=true; panStartX=e.clientX-panX; panStartY=e.clientY-panY; disableWireHits(); document.addEventListener("mousemove",doPan); document.addEventListener("mouseup",endPan);
  }
});
function doPan(e){ if(!isPanning) return; panX=e.clientX-panStartX; panY=e.clientY-panStartY; updateTransform(); updateConnections(); }
function endPan(){ isPanning=false; enableWireHits(); document.removeEventListener("mousemove",doPan); document.removeEventListener("mouseup",endPan); }

/* Touch pan/pinch */
let touchPan={active:false,id:null,startClientX:0,startClientY:0,startPanX:0,startPanY:0};
let pinch={active:false,startDist:0,startScale:1,cx:0,cy:0};
workspace.addEventListener('touchstart', e=>{
  if(e.touches.length===1 && !pinch.active){
    const t=e.touches[0];
    const target=document.elementFromPoint(t.clientX,t.clientY);
    if(target===workspace || target===wiresSVG){
      touchPan={active:true,id:t.identifier,startClientX:t.clientX,startClientY:t.clientY,startPanX:panX,startPanY:panY};
      disableWireHits(); clearSelection(); e.preventDefault();
    }
  } else if(e.touches.length===2){
    pinch.active=true;
    const dx=e.touches[1].clientX-e.touches[0].clientX;
    const dy=e.touches[1].clientY-e.touches[0].clientY;
    pinch.startDist=Math.hypot(dx,dy); pinch.startScale=scale;
    pinch.cx=(e.touches[0].clientX+e.touches[1].clientX)/2;
    pinch.cy=(e.touches[0].clientY+e.touches[1].clientY)/2;
    touchPan.active=false; e.preventDefault();
  }
},{passive:false});
workspace.addEventListener('touchmove', e=>{
  if(pinch.active && e.touches.length>=2){
    const dx=e.touches[1].clientX-e.touches[0].clientX, dy=e.touches[1].clientY-e.touches[0].clientY;
    const dist=Math.hypot(dx,dy); let newScale=pinch.startScale*dist/pinch.startDist; newScale=Math.max(.25,Math.min(3,newScale));
    const rect=canvas.getBoundingClientRect();
    const fx=(pinch.cx-rect.left-panX)/scale, fy=(pinch.cy-rect.top-panY)/scale;
    panX=pinch.cx-rect.left-fx*newScale; panY=pinch.cy-rect.top-fy*newScale; scale=newScale;
    updateTransform(); updateConnections(); e.preventDefault(); return;
  }
  if(!touchPan.active) return;
  for(const t of e.touches){
    if(t.identifier===touchPan.id){
      panX=touchPan.startPanX+(t.clientX-touchPan.startClientX);
      panY=touchPan.startPanY+(t.clientY-touchPan.startClientY);
      updateTransform(); updateConnections(); e.preventDefault(); return;
    }
  }
},{passive:false});
workspace.addEventListener('touchend', e=>{
  if(pinch.active && e.touches.length<2) pinch.active=false;
  if(!touchPan.active) return;
  let still=false; for(const t of e.touches){ if(t.identifier===touchPan.id) still=true; }
  if(!still) touchPan.active=false; enableWireHits();
});

/* DnD + selecci√≥n paleta */
components.forEach(comp=>{
  comp.addEventListener("dragstart", e=>{
    e.dataTransfer.setData("application/x-simupasir", comp.dataset.type);
    e.dataTransfer.setData("text/plain", comp.dataset.type);
    e.dataTransfer.effectAllowed='copy';
  });
  comp.addEventListener("click", ()=>{ currentToPlace = comp.dataset.type; components.forEach(c=>c.classList.remove('selected')); comp.classList.add('selected'); });
});
canvas.addEventListener("dragover", e=>{ e.preventDefault(); e.dataTransfer.dropEffect='copy'; });
canvas.addEventListener("drop", e=>{
  e.preventDefault(); if(simulation) return;
  const type=e.dataTransfer.getData("application/x-simupasir")||e.dataTransfer.getData("text/plain");
  if(!type) return; const pos=clientToWorkspace(e.clientX,e.clientY); createNode(type,pos.x,pos.y);
});

/* Paleta m√≥vil */
const fab = document.getElementById('fabPalette');
const modal = document.getElementById('paletteModal');
const grid = document.getElementById('paletteGrid');
const closePalette = document.getElementById('closePalette');

// Modo FULL guardado en este dispositivo
var isFull = false;
try { isFull = localStorage.getItem('logicsoft_full_v1') === '1'; } catch(e){}

// Tipos de bloque (lista completa para la paleta)
const PALETTE_TYPES_FULL  = ['input','output','M','and','or','not','nand','nor','xor','xnor','sr','ton','toff'];
// Lista de bloques PREMIUM
const PREMIUM_TYPES = ['sr','ton','toff'];

function isFullDevice(){
  try { return localStorage.getItem('logicsoft_full_v1') === '1'; }
  catch(e){ return !!window.isFull; }
}

function openPalette(){
  grid.innerHTML='';
  const full = isFullDevice();
  isFull = full; // actualizar bandera global

  PALETTE_TYPES_FULL.forEach(t=>{
    const b = document.createElement('button');
    b.className='pick';
    b.textContent=t.toUpperCase();

    const isPremium = PREMIUM_TYPES.includes(t);

    if (isPremium && !full){
      // Visibles pero bloqueados
      b.dataset.premium = "1";
      b.disabled = true;
      b.title = "Disponible solo en versi√≥n FULL";
    } else {
      b.onclick = ()=>{ currentToPlace=t; closePaletteModal(); };
    }
    grid.appendChild(b);
  });
  modal.style.display='block';
  modal.setAttribute('aria-hidden','false');
}

function closePaletteModal(){ modal.style.display='none'; modal.setAttribute('aria-hidden','true'); }
fab.addEventListener('click', openPalette);
closePalette.addEventListener('click', closePaletteModal);
modal.addEventListener('click', (e)=>{ if(e.target===modal) closePaletteModal(); });

/* Tap para colocar o deseleccionar */
canvas.addEventListener('click', e=>{
  if(e.target===workspace || e.target===wiresSVG){
    if(currentToPlace){
      const pos=clientToWorkspace(e.clientX,e.clientY); createNode(currentToPlace,pos.x,pos.y);
    }else{
      clearSelection();
    }
  }
});

/* Selecci√≥n general */
function selectNode(node){ if(simulation) return; clearSelection(); selectedNode=node; window.selectedNode=node; window.selectedNode=node; window.selectedNode=node; node.el.classList.add('selected'); }
function selectConnection(conn){ if(simulation) return; clearSelection(); selectedConn=conn; conn.selected=true; conn.path?.classList.add('selected'); renderConnection(conn); }
function selectTag(tag){ if(selectedTag===tag) return; selectedTag?.classList.remove('selected'); selectedTag=tag; tag.classList.add('selected'); if(selectedConn){ selectedConn.path?.classList.remove('selected'); selectedConn.selected=false; selectedConn=null; } }
function clearSelection(){
  if(selectedNode){ selectedNode.el.classList.remove('selected'); selectedNode=null; window.selectedNode=null; }

function deleteSelected(){
  if(simulation) return;
  // Prioridad: nodo seleccionado > conexi√≥n seleccionada > rama/etiqueta seleccionada
  if(selectedNode){
    removeNode(selectedNode);
    return;
  }
  if(selectedConn){
    removeConnection(selectedConn);
    return;
  }
  if(selectedBranch){
    const connByBranch = connections.find(c => c.srcBranch === selectedBranch || c.dstBranch === selectedBranch);
    if(connByBranch){
      removeConnection(connByBranch);
      return;
    }
  }
  if(selectedTag){
    const connByTag = connections.find(c => (c.srcBranch && c.srcBranch.tagEl === selectedTag) || (c.dstBranch && c.dstBranch.tagEl === selectedTag));
    if(connByTag){
      removeConnection(connByTag);
      return;
    }
  }
  // nada seleccionado: no hacemos nada, pero limpiamos estados fantasma por si acaso
  removeGhost();
}

  if(selectedConn){ selectedConn.path?.classList.remove('selected'); selectedConn.selected=false; selectedConn=null; }
  if(selectedTag){ selectedTag.classList.remove('selected'); selectedTag=null; }
  if(selectedBranch){ selectedBranch=null; }
  if(selectedPinEl){ selectedPinEl.classList.remove('pin-selected'); selectedPinEl=null; }
  pendingOutput=null; removeGhost(); hideWireMenu();
  if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; }
  connections.forEach(c=>{ (c.handles||[]).forEach(h=>h.remove()); c.handles=[]; });
}

/* Crear bloque */
let nextNodeId=1;
function createNode(type,x,y){
  const adjustedX = x - NODE_W/2;
  const adjustedY = y - NODE_H/2;

  const div=document.createElement('div'); div.className='node';
  div.dataset.type = type; div.style.left = adjustedX + 'px'; div.style.top = adjustedY + 'px';

  let display = logoLabelForType(type);
  if(type==='input')  display = `I${++inputCount}`;
  else if(type==='output') display = `Q${++outputCount}`;
  else if(type==='M')      display = `M${++memoryCount}`;

  /* Badge B001... (no para I/Q/M) */
  let blockCode=null;
  if(type!=='input' && type!=='output' && type!=='M'){
    blockCode = 'B'+zpad(++blockCodeCount);
    const badge=document.createElement('div'); badge.className='badge'; badge.textContent=blockCode; div.appendChild(badge);
  }

  const lbl=document.createElement('div'); lbl.className='label'; lbl.textContent=display; div.appendChild(lbl);
  const qind=document.createElement('div');
  // Timer display for TON/TOFF
  let tdisp=null;
  if(type==='ton' || type==='toff'){
    tdisp=document.createElement('div');
    tdisp.className='timer-display';
    const sec = Math.max(0, Math.round((((div.delayMs ?? 1000)/1000))*10)/10);
    tdisp.textContent = sec.toFixed(1) + ' s';
    div.appendChild(tdisp);
  }
 qind.className='q-indicator off'; div.appendChild(qind);

  const output=document.createElement('div'); output.className='terminal output';
  if(type==='not' || type==='nand' || type==='nor'){ output.classList.add('out-round'); }
  div.appendChild(output);

  const inputs=[];
  if(type==='input'){ div.style.background='#ffe4b5'; }
  else if(type==='output'||type==='M' || type==='ton' || type==='toff'){
    const inp=document.createElement('div'); inp.className='terminal input'; inp.style.top='50%'; div.appendChild(inp); inputs.push(inp);
  } else if(type==='not'){
    const inp=document.createElement('div'); inp.className='terminal input'; inp.style.top='50%'; div.appendChild(inp); inputs.push(inp);
  } else if(type==='sr'){
    const inS=document.createElement('div'); inS.className='terminal input'; inS.style.top='28%';
    const labelS=document.createElement('div'); labelS.className='term-label'; labelS.style.top='24%'; labelS.textContent='S';
    const inR=document.createElement('div'); inR.className='terminal input'; inR.style.top='72%';
    const labelR=document.createElement('div'); labelR.className='term-label'; labelR.style.top='68%'; labelR.textContent='R';
    div.appendChild(inS); div.appendChild(labelS); div.appendChild(inR); div.appendChild(labelR);
    inputs.push(inS); inputs.push(inR);
  }else{
    const nInputs=4;
    for(let i=0;i<nInputs;i++){
      const inp=document.createElement('div'); inp.className='terminal input';
      inp.style.top = `${(i+1)*100/(nInputs+1)}%`;
      div.appendChild(inp); inputs.push(inp);
    }
  }

  workspace.appendChild(div);

  const node={ id:nextNodeId++, el:div, type, name:display, code:blockCode, inputs, output, value:0, nextValue:0, qIndicator:qind, invalid:false };

  /* Estado extra para temporizadores */
  if(type==='ton' || type==='toff'){
    node.delayMs = 1000;     // por defecto 1s
    node.timerStart = null;  // instante de inicio del conteo
    node.prevIn = 0;         // √∫ltimo valor de entrada
  }
  if(type==='toff'){
    node.seenHigh = false;   // a√∫n no fue energizado
  }

  // Doble clic/tap para configurar temporizador (no borra el bloque)
  if(type==='ton' || type==='toff'){
    div.addEventListener('dblclick', (e)=>{ e.stopPropagation(); openTimerModal(node); });
    let lastTap=0;
    div.addEventListener('touchend', (e)=>{
      const now=e.timeStamp || Date.now();
      if(now - lastTap < 350){ openTimerModal(node); }
      lastTap=now;
    });
  }

  if(type==='sr') node.q=0;
  nodes.push(node);
  try{ if(node.type==='input'){ if(!node.el.dataset.inputMode) node.el.dataset.inputMode='momentary-no'; if(window.attachInputModeBehavior) window.attachInputModeBehavior(node, true);} }catch(e){}

  if(node.output){ node.output.style.top='50%'; node.output.style.transform='translateY(-50%)'; }

  div.addEventListener('click', e=>{ if(e.target.classList.contains('terminal')) return; if(simulation) return; selectNode(node); });
  if(type==='input'){
    div.addEventListener('click', (function(){ /* [patched] disabled legacy toggle to respect mode */ }));
  }

  dragMove(div,node);
  enableConnections(node);
  div.addEventListener('contextmenu', e=>{ e.preventDefault(); if(!simulation) removeNode(node); });


  // Update timer countdown labels
  nodes.forEach(n=>{
    if(n.type==='ton' || n.type==='toff'){
      let disp = n.el.querySelector('.timer-display');
      if(!disp){
        disp=document.createElement('div');
        disp.className='timer-display';
        n.el.appendChild(disp);
      }
      const delay = (n.delayMs ?? 1000);
      let sec = delay/1000;
      if(simulation && n.timerStart){
        const tnow = nowMs();
        let remaining = Math.max(0, delay - (tnow - n.timerStart));
        sec = remaining/1000;
      }
      disp.textContent = sec.toFixed(1) + ' s';
    }
  });

  updateConnections();
}

/* Mover bloque (cuando est√° seleccionado) */
function dragMove(el,node){
  let sx,sy,ix,iy,dragging=false;
  el.addEventListener('mousedown', e=>{
    if(e.target.classList.contains('terminal')) return;
    if(simulation) return;
    if(selectedNode!==node) return;
    e.preventDefault(); sx=e.clientX; sy=e.clientY; ix=parseFloat(el.style.left); iy=parseFloat(el.style.top);
    dragging=true; document.addEventListener('mousemove',onMove); document.addEventListener('mouseup',onUp);
  });
  function onMove(e){ if(!dragging) return; el.style.left=ix+(e.clientX-sx)/scale+'px'; el.style.top=iy+(e.clientY-sy)/scale+'px'; updateConnections(); }
  function onUp(){ dragging=false; document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp); }
  el.addEventListener('touchstart', e=>{
    if(simulation) return; if(selectedNode!==node) return;
    const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; ix=parseFloat(el.style.left); iy=parseFloat(el.style.top);
    dragging=true; document.addEventListener('touchmove',onTouchMove,{passive:false}); document.addEventListener('touchend',onTouchEnd);
    e.stopPropagation(); e.preventDefault();
  },{passive:false});
  function onTouchMove(e){ if(!dragging) return; const t=e.changedTouches[0]; el.style.left=ix+(t.clientX-sx)/scale+'px'; el.style.top=iy+(t.clientY-sy)/scale+'px'; updateConnections(); e.preventDefault(); }
  function onTouchEnd(){ dragging=false; document.removeEventListener('touchmove',onTouchMove); document.removeEventListener('touchend',onTouchEnd); }
}


/* === NOT por pin de entrada === */
function toggleNotOnInput(inp){
  inp.classList.toggle('not');
  inp.dataset.not = inp.classList.contains('not') ? '1' : '0';

  // Update timer countdown labels
  nodes.forEach(n=>{
    if(n.type==='ton' || n.type==='toff'){
      let disp = n.el.querySelector('.timer-display');
      if(!disp){
        disp=document.createElement('div');
        disp.className='timer-display';
        n.el.appendChild(disp);
      }
      const delay = (n.delayMs ?? 1000);
      let sec = delay/1000;
      if(simulation && n.timerStart){
        const tnow = nowMs();
        let remaining = Math.max(0, delay - (tnow - n.timerStart));
        sec = remaining/1000;
      }
      disp.textContent = sec.toFixed(1) + ' s';
    }
  });

  updateConnections();
}

/* Conexiones y pines */
function enableConnections(node){
  const handler = el=>{
    if(simulation) return;
    if(el.classList.contains('output')){
      selectedPinEl?.classList.remove('pin-selected');
      selectedPinEl=el; el.classList.add('pin-selected');
      pendingOutput=el; showGhost(el); return;
    }
    if(el.classList.contains('input')){
      el.classList.add('pin-target'); setTimeout(()=>el.classList.remove('pin-target'),300);
      if(!pendingOutput) return;
      if(pendingOutput===el){ removeGhost(); selectedPinEl?.classList.remove('pin-selected'); selectedPinEl=null; pendingOutput=null; return; }
      createConnection(pendingOutput, el);
      removeGhost(); selectedPinEl?.classList.remove('pin-selected'); selectedPinEl=null; pendingOutput=null;
    }
  };
  node.output && node.output.addEventListener('click', ()=>handler(node.output));
  node.inputs.forEach(inp=>{
    inp.addEventListener('click', ()=>handler(inp));
    // Doble clic / doble tap para invertir (NOT) este pin de entrada
    inp.addEventListener('dblclick', (e)=>{ e.stopPropagation(); toggleNotOnInput(inp); });
    let __lastTap=0; inp.addEventListener('touchend',(e)=>{ const now=e.timeStamp||Date.now(); if(now-__lastTap<350){ toggleNotOnInput(inp); } __lastTap=now; }, {passive:true});
  });
}

/* Ghost al crear conexi√≥n */
function showGhost(fromTerm){ if (isPanning) return;
  removeGhost();
  const s=terminalEdge(fromTerm);
  const path=document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("class","wire-path ghost"); updateGhostPath(path,s.x,s.y,s.x,s.y);
  wiresSVG.appendChild(path); pendingGhost=path;
  workspace.addEventListener('mousemove',trackGhost);
  workspace.addEventListener('touchmove',trackGhostTouch,{passive:false});
}
function removeGhost(){
  pendingGhost?.remove(); pendingGhost=null;
  workspace.removeEventListener('mousemove',trackGhost);
  workspace.removeEventListener('touchmove',trackGhostTouch);
}
function trackGhost(e){ if(!pendingGhost||!pendingOutput||isPanning) return; const p=clientToWorkspace(e.clientX,e.clientY); const s=terminalEdge(pendingOutput); updateGhostPath(pendingGhost,s.x,s.y,p.x,p.y); }
function trackGhostTouch(e){ if(!pendingGhost||!pendingOutput||isPanning) return; const t=e.touches[0]; const p=clientToWorkspace(t.clientX,t.clientY); const s=terminalEdge(pendingOutput); updateGhostPath(pendingGhost,s.x,s.y,p.x,p.y); e.preventDefault(); }
function updateGhostPath(path,sx,sy,ex,ey){ const midX=(sx+ex)/2; path.setAttribute('d',`M${sx},${sy} L${midX},${sy} L${midX},${ey} L${ex},${ey}`); }

/* ===== Etiquetas & hubs ===== */
function getSourceName(conn){
  const srcNode = nodes.find(n=>n.output===conn.from);
  if(!srcNode) return '??';
  if(srcNode.type==='input'||srcNode.type==='output'||srcNode.type==='M') return srcNode.name;
  return srcNode.code || 'B???';
}
function getDestNameWithPin(conn){
  const dstNode = nodes.find(n=>n.inputs.includes(conn.to));
  if(!dstNode) return '??';
  const pinIndex = 1 + dstNode.inputs.indexOf(conn.to);
  if(dstNode.type==='input'||dstNode.type==='output'||dstNode.type==='M') return `${dstNode.name}/${pinIndex}`;
  return `${dstNode.code || 'B???'}/${pinIndex}`;
}
function ensureHub(pinEl){
  let hub = outputHubs.get(pinEl);
  if(hub) return hub;
  const p = terminalEdge(pinEl);
  const x = p.x + 18, y = p.y;
  const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
  dot.setAttribute('cx', x); dot.setAttribute('cy', y); dot.setAttribute('r', 6);
  dot.setAttribute('class','hub-dot');
  const hit = document.createElementNS("http://www.w3.org/2000/svg","circle");
  hit.setAttribute('cx', x); hit.setAttribute('cy', y); hit.setAttribute('r', 18);
  hit.setAttribute('class','hub-hit');
  const stem = document.createElementNS("http://www.w3.org/2000/svg","path");
  stem.setAttribute('class','wire-path');
  wiresSVG.appendChild(stem); wiresSVG.appendChild(hit); wiresSVG.appendChild(dot);
  const hubObj = { x, y, dot, hit, stemPath:stem, pin:pinEl, branches:new Set() };
  outputHubs.set(pinEl, hubObj);

  const startDrag = (ev)=>{
    ev.stopPropagation();
    const start = (ev.touches? ev.touches[0]:ev);
    const s = clientToWorkspace(start.clientX, start.clientY);
    const ox = hubObj.x, oy = hubObj.y;
    const move = (ev2)=>{
      const cur = (ev2.touches? ev2.touches[0]:ev2);
      const wp = clientToWorkspace(cur.clientX, cur.clientY);
      hubObj.x = ox + (wp.x - s.x);
      hubObj.y = oy + (wp.y - s.y);
      renderHub(hubObj);
    };
    const end = ()=>{
      document.removeEventListener('mousemove',move);
      document.removeEventListener('mouseup',end);
      document.removeEventListener('touchmove',move);
      document.removeEventListener('touchend',end);
    };
    document.addEventListener('mousemove',move);
    document.addEventListener('mouseup',end);
    document.addEventListener('touchmove',move,{passive:false});
    document.addEventListener('touchend',end,{passive:true});
  };
  dot.addEventListener('mousedown',startDrag);
  dot.addEventListener('touchstart',startDrag,{passive:false});
  hit.addEventListener('mousedown',startDrag);
  hit.addEventListener('touchstart',startDrag,{passive:false});

  renderHub(hubObj);
  return hubObj;
}
function renderHub(hub){
  hub.dot.setAttribute('cx', hub.x); hub.dot.setAttribute('cy', hub.y);
  hub.hit.setAttribute('cx', hub.x); hub.hit.setAttribute('cy', hub.y);
  const e = terminalEdge(hub.pin);
  const d = `M${e.x},${e.y} L${hub.x-10},${e.y} L${hub.x-10},${hub.y} L${hub.x},${hub.y}`;
  hub.stemPath.setAttribute('d', d);
  for (const br of hub.branches) renderBranch(br);
}
function createTagEl(text, isSource){
  const tag = document.createElement('div');
  tag.className = 'conn-tag' + (isSource ? ' conn-tag-src' : '');
  tag.textContent = text;
  workspace.appendChild(tag);
  return tag;
}
function attachDragToTag(branch){
  const tag = branch.tagEl;
  let dragging=false, sx=0, sy=0, ox=0, oy=0;
  const start=(ev)=>{
    ev.stopPropagation();
    dragging=true;
    const pt=(ev.touches? ev.touches[0]:ev);
    const wp=clientToWorkspace(pt.clientX, pt.clientY);
    sx=wp.x; sy=wp.y; ox=branch.tx; oy=branch.ty;
    document.addEventListener('mousemove',move);
    document.addEventListener('mouseup',end);
    document.addEventListener('touchmove',move,{passive:false});
    document.addEventListener('touchend',end,{passive:true});
  };
  const move=(ev)=>{
    if(!dragging) return;
    const pt=(ev.touches? ev.touches[0]:ev);
    const wp=clientToWorkspace(pt.clientX, pt.clientY);
    branch.tx = ox + (wp.x - sx);
    branch.ty = oy + (wp.y - sy);
    renderBranch(branch);
    ev.preventDefault?.();
  };
  const end=()=>{
    dragging=false;
    document.removeEventListener('mousemove',move);
    document.removeEventListener('mouseup',end);
    document.removeEventListener('touchmove',move);
    document.removeEventListener('touchend',end);
  };
  tag.addEventListener('mousedown', start);
  tag.addEventListener('touchstart', start, {passive:false});
  tag.addEventListener('click', (e)=>{ e.stopPropagation(); selectTag(tag); });
}
function createBranch({fromHub, hub, fromPin, pinEl, text}){
  const path = document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute('class','wire-path');
  const hit  = document.createElementNS("http://www.w3.org/2000/svg","path");
  hit.setAttribute('class','wire-hit');
  wiresSVG.appendChild(hit); wiresSVG.appendChild(path);
  const tag = createTagEl(text, !!fromHub);
  let start;
  if(fromHub) start = {x:hub.x, y:hub.y};
  else { const e=terminalEdge(pinEl); start = {x:e.x-40, y:e.y}; }
  const branch = { fromHub, hub, fromPin, pinEl, path, hit, tagEl:tag, bends:[], tx: start.x + (fromHub? 60 : -60), ty: start.y - 20 };
  const onLP = (ev)=>{
    ev.stopPropagation();
    let cancelled=false;
    const cancel=()=>{ cancelled=true; if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; } document.removeEventListener('mouseup',cancel); document.removeEventListener('touchend',cancel); };
    document.addEventListener('mouseup',cancel,{once:true});
    document.addEventListener('touchend',cancel,{once:true,passive:true});
    longPressTimer=setTimeout(()=>{
      if(cancelled) return;
      const pt=(ev.type==='mousedown')?ev:(ev.touches?.[0] ?? ev);
      const wp=clientToWorkspace(pt.clientX, pt.clientY);
      branch.bends.push({x:wp.x, y:wp.y});
      renderBranch(branch);
    },400);
  };
  path.addEventListener('mousedown', onLP);
  path.addEventListener('touchstart', onLP, {passive:false});
  hit .addEventListener('mousedown', onLP);
  hit .addEventListener('touchstart', onLP, {passive:false});
  attachDragToTag(branch);
  renderBranch(branch);
  const onSel=(e)=>{ e.stopPropagation(); selectedBranch=branch; selectTag(tag); };
  hit.addEventListener('click', onSel);
  hit.addEventListener('touchstart', onSel, {passive:true});
  return branch;
}
function renderBranch(branch){
  const sx = branch.fromHub ? branch.hub.x : terminalEdge(branch.pinEl).x;
  const sy = branch.fromHub ? branch.hub.y : terminalEdge(branch.pinEl).y;
  const ex = branch.tx, ey = branch.ty;
  let d='';
  if(branch.bends.length===0){
    const midX=(sx+ex)/2; d=`M${sx},${sy} L${midX},${sy} L${midX},${ey} L${ex},${ey}`;
  }else{
    const pts=[{x:sx,y:sy}].concat(branch.bends).concat([{x:ex,y:ey}]);
    d=`M${pts[0].x},${pts[0].y} `; for(let i=1;i<pts.length;i++){ const prev=pts[i-1], next=pts[i]; d+=`L${next.x},${prev.y} L${next.x},${next.y} `; }
  }
  branch.path.setAttribute('d', d);
  branch.hit.setAttribute('d', d);
  branch.tagEl.style.left = ex + 'px';
  branch.tagEl.style.top  = ey + 'px';
}
function convertWireToLabel(conn){
  // Eliminar el cable original y sus handles
  if (conn.path) { conn.path.remove(); conn.path = null; }
  if (conn.hit)  { conn.hit.remove();  conn.hit  = null; }
  (conn.handles || []).forEach(h => h.remove());
  conn.handles = [];

  // Nombres para las etiquetas
  const srcName = getDestNameWithPin(conn);
  const inName  = getSourceName(conn);

  // ‚ú® Cambio clave:
  // NO creamos hub en el pin de salida (evita el nodo que aparec√≠a).
  // En su lugar, ambas ramas salen directamente de sus pines.
  const srcBranch = createBranch({ fromHub:false, pinEl: conn.from, text: srcName });
  conn.srcBranch = srcBranch;

  const dstBranch = createBranch({ fromHub:false, pinEl: conn.to,   text: inName  });
  conn.dstBranch = dstBranch;

  conn.mode = 'label';
  renderConnection(conn);
}
/* Crear conexi√≥n normal */
function createConnection(fromTerm,toTerm){
  if(simulation) return;
  if(connections.find(c => c.from===fromTerm && c.to===toTerm)) return;
  const conn={ from:fromTerm, to:toTerm, path:null, hit:null, bends:[], handles:[], selected:false, mode:'wire', srcBranch:null, dstBranch:null };
  connections.push(conn); renderConnection(conn);
}

/* Men√∫ contextual cables */
const wireMenu = document.getElementById('wireMenu');
const menuAddNode = document.getElementById('menuAddNode');
const menuMakeLabel = document.getElementById('menuMakeLabel');
let menuContext = { conn:null, clientX:0, clientY:0 };
function showWireMenu(conn, clientX, clientY){
  menuContext = { conn, clientX, clientY };
  wireMenu.style.display='block';
  const vw = window.innerWidth, vh = window.innerHeight;
  const menuW = 260, menuH = 90;
  let x = clientX, y = clientY;
  if(x + menuW > vw) x = vw - menuW - 8;
  if(y + menuH > vh) y = vh - menuH - 8;
  wireMenu.style.left = x + 'px';
  wireMenu.style.top  = y + 'px';
}
function hideWireMenu(){ wireMenu.style.display='none'; }
menuAddNode.addEventListener('click', ()=>{
  const {conn, clientX, clientY} = menuContext;
  hideWireMenu();
  if(!conn) return;
  const pos=clientToWorkspace(clientX, clientY);
  conn.bends.push({x:pos.x,y:pos.y}); selectConnection(conn); renderConnection(conn);
});
menuMakeLabel.addEventListener('click', ()=>{
  const {conn} = menuContext;
  hideWireMenu();
  if(!conn) return;
  convertWireToLabel(conn);
});
document.addEventListener('click', (e)=>{ if(e.target!==wireMenu && !wireMenu.contains(e.target)) hideWireMenu(); });

/* ===== Se√±al visual ===== */
function applySignalStyles(conn, val){
  try{
    conn.from.classList.toggle('signal-on', val===1);
    conn.to.classList.toggle('signal-on',   val===1);
  }catch(e){}
  if(conn.mode==='label'){
    if(conn.srcBranch){
      conn.srcBranch.path.classList.toggle('signal', val===1);
      conn.srcBranch.tagEl.classList.toggle('signal', val===1);
    }
    if(conn.dstBranch){
      conn.dstBranch.path.classList.toggle('signal', val===1);
      conn.dstBranch.tagEl.classList.toggle('signal', val===1);
    }
    const hub = outputHubs.get(conn.from);
    if(hub){
      hub.stemPath.classList.toggle('signal', val===1);
      hub.dot.classList.toggle('signal', val===1);
    }
  }else{
    if(conn.path) conn.path.classList.toggle('signal', val===1);
  }
  const srcNode=nodes.find(n=>n.output===conn.from);
  if(srcNode){
    srcNode.qIndicator && srcNode.qIndicator.classList.toggle('on', val===1);
    srcNode.el.classList.toggle('has-signal', srcNode.value===1);
  }
  const dstNode=nodes.find(n=>n.inputs.includes(conn.to));
  if(dstNode){
    dstNode.el.classList.toggle('has-signal', dstNode.value===1);
  }
}

/* Render conexi√≥n */
function renderConnection(conn){
  if(conn.mode==='label'){
    if(conn.srcBranch) renderBranch(conn.srcBranch);
    if(conn.dstBranch) renderBranch(conn.dstBranch);
    const hub = outputHubs.get(conn.from);
    hub && renderHub(hub);
    const val = getSourceNodeValue(conn);
    applySignalStyles(conn, val);
    return;
  }
  conn.path?.remove(); conn.hit?.remove();
  (conn.handles||[]).forEach(h=>h.remove()); conn.handles=[];
  const s=terminalEdge(conn.from), e=terminalEdge(conn.to);
  let d='';
  if(conn.bends.length===0){
    const midX=(s.x+e.x)/2; d=`M${s.x},${s.y} L${midX},${s.y} L${midX},${e.y} L${e.x},${e.y}`;
  }else{
    const pts=[{x:s.x,y:s.y}].concat(conn.bends).concat([{x:e.x,y:e.y}]);
    d=`M${pts[0].x},${pts[0].y} `; for(let i=1;i<pts.length;i++){ const prev=pts[i-1], next=pts[i]; d+=`L${next.x},${prev.y} L${next.x},${next.y} `; }
  }
  const hit=document.createElementNS("http://www.w3.org/2000/svg","path");
  hit.setAttribute("d",d); hit.setAttribute("class","wire-hit");
  const path=document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("d",d); path.setAttribute("class","wire-path");
  if(conn.selected) path.classList.add('selected');
  const val=getSourceNodeValue(conn);
  const onSelect=(ev)=>{ ev.stopPropagation(); if(simulation) return; selectConnection(conn); };
  hit.addEventListener('click',onSelect);
  hit.addEventListener('touchstart',onSelect,{passive:true});
  hit.addEventListener('contextmenu',(ev)=>{ ev.preventDefault(); if(simulation) return; showWireMenu(conn, ev.clientX, ev.clientY); });
  function onPathDown(ev){
    if(simulation) return;
    if(ev.type==='mousedown' && ev.button!==0) return;
    ev.stopPropagation();
    let cancelled=false;
    const cancel=()=>{ cancelled=true; if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; } document.removeEventListener('mouseup',cancel); document.removeEventListener('touchend',cancel); };
    document.addEventListener('mouseup',cancel,{once:true});
    document.addEventListener('touchend',cancel,{once:true,passive:true});
    longPressTimer=setTimeout(()=>{
      if(cancelled) return;
      const clientX=(ev.type==='mousedown')?ev.clientX:(ev.touches?.[0]?.clientX ?? ev.clientX);
      const clientY=(ev.type==='mousedown')?ev.clientY:(ev.touches?.[0]?.clientY ?? ev.clientY);
      showWireMenu(conn, clientX, clientY);
    },400);
  }
  path.addEventListener('mousedown',onPathDown);
  path.addEventListener('touchstart',onPathDown,{passive:false});
  hit .addEventListener('mousedown',onPathDown);
  hit .addEventListener('touchstart',onPathDown,{passive:false});
  wiresSVG.appendChild(hit); wiresSVG.appendChild(path);
  conn.hit=hit; conn.path=path;
  applySignalStyles(conn, val);
  if(conn.selected && !simulation){
    conn.handles=[];
    conn.bends.forEach((b,idx)=>{
      const g=document.createElementNS("http://www.w3.org/2000/svg","g");
      const hitC=document.createElementNS("http://www.w3.org/2000/svg","circle");
      hitC.setAttribute('cx',b.x); hitC.setAttribute('cy',b.y); hitC.setAttribute('r',24); hitC.setAttribute('class','bend-hit');
      const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute('cx',b.x); c.setAttribute('cy',b.y); c.setAttribute('r',11); c.setAttribute('class','bend-handle');
      g.appendChild(hitC); g.appendChild(c); wiresSVG.appendChild(g);
      conn.handles.push(c);
      const start=(ev)=>{ if(simulation) return; ev.stopPropagation(); startDraggingHandle(conn, idx); };
      c.addEventListener('mousedown',start); c.addEventListener('touchstart',start,{passive:true});
      hitC.addEventListener('mousedown',start); hitC.addEventListener('touchstart',start,{passive:true});
    });
  }
}

/* Bend dragging */
function startDraggingHandle(conn,index){
  if(conn.handles && conn.handles[index]) conn.handles[index].classList.add('dragging');
  draggingBend={conn,index};
  document.addEventListener('mousemove',onBendMove);
  document.addEventListener('mouseup',stopDraggingHandle);
  document.addEventListener('touchmove',onBendMoveTouch,{passive:false});
  document.addEventListener('touchend',stopDraggingHandle,{passive:true});
}
function stopDraggingHandle(){
  if(!draggingBend) return;
  const {conn,index}=draggingBend;
  if(conn.handles && conn.handles[index]) conn.handles[index].classList.remove('dragging');
  draggingBend=null;
  document.removeEventListener('mousemove',onBendMove);
  document.removeEventListener('mouseup',stopDraggingHandle);
  document.removeEventListener('touchmove',onBendMoveTouch);
  document.removeEventListener('touchend',stopDraggingHandle);
}
function onBendMove(ev){
  if(!draggingBend) return;
  const pos=clientToWorkspace(ev.clientX,ev.clientY);
  const {conn,index}=draggingBend;
  conn.bends[index].x=pos.x; conn.bends[index].y=pos.y;
  renderConnection(conn);
}
function onBendMoveTouch(ev){
  if(!draggingBend) return; ev.preventDefault();
  const t=ev.touches[0]; const pos=clientToWorkspace(t.clientX,t.clientY);
  const {conn,index}=draggingBend;
  conn.bends[index].x=pos.x; conn.bends[index].y=pos.y;
  renderConnection(conn);
}

/* Utilidades */
function getSourceNodeValue(conn){ const n=nodes.find(nn=>nn.output===conn.from); return n? n.value:0; }
function updateConnections(){ connections = connections.filter(c => c.from && c.to && document.body.contains(c.from) && document.body.contains(c.to)); connections.forEach(c=>renderConnection(c)); }

/* Eliminar bloque + cables asociados y limpiar hubs */
function removeNode(node){
  if(simulation) return;
  if(selectedPinEl && (selectedPinEl===node.output || node.inputs.includes(selectedPinEl))){
    selectedPinEl.classList.remove('pin-selected'); selectedPinEl=null; pendingOutput=null; removeGhost();
  }
  const toRemove = connections.filter(c=> c.from===node.output || node.inputs.includes(c.to) );
  toRemove.forEach(removeConnection);
  if(node.output){
    const hub = outputHubs.get(node.output);
    if(hub){
      for(const br of hub.branches){ br.tagEl.remove(); br.path.remove(); br.hit.remove(); }
      hub.stemPath.remove(); hub.dot.remove(); hub.hit.remove();
      outputHubs.delete(node.output);
    }
  }
  node.el.remove();
  nodes = nodes.filter(n=>n!==node);
  clearSelection(); updateConnections();
}
function removeConnection(conn){
  if(!conn) return;
  conn.path && conn.path.remove(); conn.hit && conn.hit.remove();
  (conn.handles||[]).forEach(h=>h.remove()); conn.handles=[];
  if(conn.srcBranch){
    const hub = conn.srcBranch.hub;
    if(hub){ hub.branches.delete(conn.srcBranch); }
    conn.srcBranch.tagEl.remove(); conn.srcBranch.path.remove(); conn.srcBranch.hit.remove();
    conn.srcBranch=null;
    if(hub && hub.branches.size===0){
      hub.stemPath.remove(); hub.dot.remove(); hub.hit.remove();
      outputHubs.delete(hub.pin);
    }
  }
  if(conn.dstBranch){
    conn.dstBranch.tagEl.remove(); conn.dstBranch.path.remove(); conn.dstBranch.hit.remove();
    conn.dstBranch=null;
  }
  const i=connections.indexOf(conn); if(i>=0) connections.splice(i,1);
  if(selectedConn===conn) selectedConn=null;
  if(selectedTag && (selectedTag===conn.tagSrcEl || conn.tagDstEl===selectedTag)){ selectedTag.classList.remove('selected'); selectedTag=null; }

  removeGhost && removeGhost();
  if (typeof selectedPinEl!=='undefined' && (selectedPinEl===conn.from || selectedPinEl===conn.to)) { try{ selectedPinEl.classList.remove('pin-selected'); }catch(e){} selectedPinEl=null; }
  if (typeof pendingOutput!=='undefined') pendingOutput=null;
}

/* ===== L√≥gica de compuertas y temporizadores ===== */
function evaluateGate(type,inputs){
  if(inputs.length===0) return 0;
  switch(type){
    case 'and': return inputs.every(v=>v===1)?1:0;
    case 'or':  return inputs.some(v=>v===1)?1:0;
    case 'not': return inputs[0]?0:1;
    case 'nand':return inputs.every(v=>v===1)?0:1;
    case 'nor': return inputs.some(v=>v===1)?0:1;
    case 'xor': return inputs.reduce((a,b)=>a^b,0);
    case 'xnor':return evaluateGate('xor',inputs)?0:1;
    default: return inputs[0]||0;
  }
}
function nowMs(){ return performance.now ? performance.now() : Date.now(); }

function scanLogic(){

  const tnow = nowMs();
  // 1) Leer entradas del DOM
  nodes.forEach(n=>{
    if(n.type==='input') n.value = n.el.classList.contains('active')?1:0;
    n.invalid=false;
  });

  // 2) Propagaci√≥n multi-pass para cerrar realimentaciones en este mismo scan
  const MAX_ITERS = 6;
  const values = new Map();
  nodes.forEach(n => values.set(n, n.value||0));

  function inputsOf(node){
    return connections
      .filter(c => node.inputs.includes(c.to))
      .map(c => {
        const src = nodes.find(n => n.output === c.from);
        let v = src ? (values.get(src)||0) : 0;
        if (c.to && c.to.dataset && c.to.dataset.not==='1') v = v ? 0 : 1;
        return v;
      });
  }

  function gateEval(type, ins){
    const sum = ins.reduce((a,b)=>a+(b?1:0),0);
    const all = ins.every(Boolean);
    const any = ins.some(Boolean);
    switch((type||'').toLowerCase()){
      case 'and': return all;
      case 'or': return any;
      case 'nand': return !all;
      case 'nor': return !any;
      case 'xor': return sum % 2 === 1;
      case 'xnor': return sum % 2 === 0;
      case 'not': return !ins[0];
      default: return any; // ‚â•1
    }
  }

  for(let k=0;k<MAX_ITERS;k++){
    let changed=false;
    nodes.forEach(node=>{
      if(node.type==='input'){ return; }
      const inVals = inputsOf(node);
      const in0 = (inVals[0]??0);
      let next;

      if(node.type==='output' || node.type==='M'){
        next = in0 ? 1 : 0;

      } else if(node.type==='sr'){
        const S = inVals[0]?1:0, R=inVals[1]?1:0;
        const q = values.get(node)||node.q||0;
        if(S===1 && R===0) next=1;
        else if(S===0 && R===1) next=0;
        else next=q;

      } else if(node.type==='ton'){
        const delay = node.delayMs ?? 1000;
        let curr = values.get(node)||0;
        if(in0===1){
          if(node.timerStart==null) node.timerStart = tnow;
          curr = (tnow - node.timerStart >= delay) ? 1 : 0;
        } else {
          node.timerStart = null;
          curr = 0;
        }
        next = curr;

      } else if(node.type==='toff'){
        const delay = node.delayMs ?? 1000;
        let curr = values.get(node)||0;
        if(in0===1){
          node.seenHigh = true;
          node.timerStart = null;
          curr = 1;
        } else {
          if(!node.seenHigh){
            curr = 0;
            node.timerStart = null;
          } else {
            if(node.timerStart==null) node.timerStart = tnow;
            curr = (tnow - node.timerStart >= delay) ? 0 : 1;
          }
        }
        next = curr;

      } else {
        next = gateEval(node.type, inVals) ? 1 : 0;
      }

      if(next !== (values.get(node)||0)){
        values.set(node, next);
        changed = true;
      }
    });
    if(!changed) break;
  }

  // 3) Fijar values/nextValue
  nodes.forEach(n=>{ n.nextValue = values.get(n)||0; });
  nodes.forEach(n=>{ n.value=n.nextValue; if(n.type==='sr') n.q=n.nextValue; });

  // 4) Visual de bloques (respetando tu dise√±o)
  nodes.forEach(n=>{
    n.el.classList.toggle('has-signal', n.value===1);
    if(n.type==='input' || n.type==='output' || n.type==='M'){
      n.el.classList.toggle('active', n.value===1);
      n.output && n.output.classList.toggle('signal-on', n.value===1);
    }
    if(n.qIndicator) n.qIndicator.classList.toggle('on', n.value===1);
    if(n.type==='ton' || n.type==='toff'){
      let disp = n.el.querySelector('.timer-display');
      if(!disp){
        disp=document.createElement('div');
        disp.className='timer-display';
        n.el.appendChild(disp);
      }
      const delay = (n.delayMs ?? 1000);
      let sec = delay/1000;
      if(simulation && n.timerStart){
        const tnow2 = nowMs();
        let remaining = Math.max(0, delay - (tnow2 - n.timerStart));
        sec = remaining/1000;
      }
      disp.textContent = sec.toFixed(1) + ' s';
    }
  });

  // 5) Reconstruir/actualizar conexiones ‚Üí aplica se√±al a cables y pines con applySignalStyles()
  updateConnections();

}

/* Botones simulaci√≥n y zoom */
document.getElementById('simulate').addEventListener('click', ()=>{
  if(simulation) return;
  clearSelection(); simulation=true;
  document.getElementById('simulate')?.classList.add('active');
  // init displays with assigned seconds
  nodes.forEach(n=>{ if(n.type==='ton'||n.type==='toff'){ const d=n.el.querySelector('.timer-display'); if(d){ const sec=((n.delayMs??1000)/1000).toFixed(1); d.textContent=sec+' s'; } } });
  document.getElementById('stop')?.classList.remove('active');
  nodes.forEach(n=>{
    if(n.type==='ton' || n.type==='toff'){
      n.timerStart = null;
      n.prevIn = 0;
    }
    if(n.type==='toff'){ n.seenHigh = false; }
  });
  
  /* === NC/NO default enforcement (every start behaves like first start) === */
  try{
    nodes.forEach(n=>{
      if(!n || n.type!=='input' || !n.el) return;
      // Use the app's own behavior if available to reset defaults
      if (typeof window.attachInputModeBehavior === 'function'){
        window.attachInputModeBehavior(n, true);
      }
      const el = n.el;
      const mode = (el.dataset?.inputMode || el.dataset?.mode || '').toLowerCase();
      // NC (momentary-nc / toggle-nc / nc=true) => start ACTIVE (1)
      if (mode.includes('momentary-nc') || mode.includes('toggle-nc') || el.dataset?.nc === 'true'){
        el.classList.add('active');
        if ('value' in n) n.value = 1;
      // Momentary NO => start INACTIVE (0)
      } else if (mode.includes('momentary-no')){
        el.classList.remove('active');
        if ('value' in n) n.value = 0;
      }
    });
  }catch(_){}
  /* === End NC/NO enforcement === */
scanLogic(); simTimer=setInterval(scanLogic,SCAN_MS);
});
document.getElementById('stop').addEventListener('click', ()=>{
  if(simTimer){ clearInterval(simTimer); simTimer=null; }
  simulation=false;
  nodes.forEach(n=>{
    n.value=0;
    n.el.classList.remove('has-signal','active');
    if(n.type==='input'||n.type==='output'||n.type==='M') n.el.classList.remove('active');
    n.qIndicator && n.qIndicator.classList.remove('on');
    n.invalid=false;
    n.output && n.output.classList.remove('signal-on');
    n.inputs?.forEach(inp=>inp.classList.remove('signal-on'));
    if(n.type==='ton' || n.type==='toff'){ n.timerStart=null; n.prevIn=0; }
    if(n.type==='toff'){ n.seenHigh=false; }
  
  document.getElementById('simulate')?.classList.remove('active');
  // reset displays
  nodes.forEach(n=>{ if(n.type==='ton'||n.type==='toff'){ const d=n.el.querySelector('.timer-display'); if(d){ const sec=((n.delayMs??1000)/1000).toFixed(1); d.textContent=sec+' s'; } } });
  document.getElementById('stop')?.classList.remove('active');

  // -- Reset total adicional --
  try{ clearSelection && clearSelection(); }catch(_){}
  nodes.forEach(n=>{
    if('nextValue' in n) n.nextValue = 0;
    if('q' in n) n.q = 0;
    if('selected' in n) n.selected = false;
    if(n.el){ n.el.classList.remove('selected','dragging'); }
  });
  // Quitar se√±ales residuales en SVG/canvas si existieran
  try{
    document.querySelectorAll('.signal-on,.has-signal,.active-wire').forEach(el=>el.classList.remove('signal-on','has-signal','active-wire'));
  }catch(_){}
});
  connections.forEach(c=>applySignalStyles(c, 0));

  // Update timer countdown labels
  nodes.forEach(n=>{
    if(n.type==='ton' || n.type==='toff'){
      let disp = n.el.querySelector('.timer-display');
      if(!disp){
        disp=document.createElement('div');
        disp.className='timer-display';
        n.el.appendChild(disp);
      }
      const delay = (n.delayMs ?? 1000);
      let sec = delay/1000;
      if(simulation && n.timerStart){
        const tnow = nowMs();
        let remaining = Math.max(0, delay - (tnow - n.timerStart));
        sec = remaining/1000;
      }
      disp.textContent = sec.toFixed(1) + ' s';
    }
  });

  updateConnections();
});
document.getElementById('zoomIn').addEventListener('click', ()=>setZoom(scale+0.12));
document.getElementById('zoomOut').addEventListener('click', ()=>setZoom(scale-0.12));

/* Eliminar selecci√≥n (pero NO cuando est√°s escribiendo en inputs) */
document.addEventListener('keydown', (e)=>{
  const tag = (e.target && e.target.tagName || '').toLowerCase();

// Click del bot√≥n Eliminar
if (typeof deleteBtn !== 'undefined' && deleteBtn) {
  deleteBtn.addEventListener('click', () => {
    if(simulation) return;
    deleteSelected();
  });
}
  if(tag==='input' || tag==='textarea' || e.target.isContentEditable) return; // <- protege al editar tiempo
  if(e.key==='Delete' || e.key==='Backspace'){
    if(simulation) return;
    deleteSelected();
  }
  if(e.key==='Escape'){ clearSelection(); }
});

/* Redibuja en resize */
window.addEventListener('resize', updateConnections);

/* ====== Guardar / Importar ====== */
function serialize(){
  // mapear pines por √≠ndice
  const nodeIndex = new Map(nodes.map((n,i)=>[n, i]));
  const data = {
    meta:{ app:"SIMUPASIR", version:1 },
    counts:{ inputCount, outputCount, memoryCount, blockCodeCount, nextNodeId },
    nodes: nodes.map(n=>({
      id:n.id, type:n.type, name:n.name, code:n.code,
      x:parseFloat(n.el.style.left)||0, y:parseFloat(n.el.style.top)||0,
      delayMs: (n.type==='ton' || n.type==='toff') ? (n.delayMs ?? 1000) : undefined
    })),
    connections: connections.map(c=>{
      const fromNode = nodes.find(n=>n.output===c.from);
      const toNode   = nodes.find(n=>n.inputs.includes(c.to));
      const toIndex  = toNode ? toNode.inputs.indexOf(c.to) : 0;
      return { fromId: fromNode?.id, toId: toNode?.id, toIndex, mode:c.mode||'wire' };
    })
  };
  return data;
}
function download(filename, text){
  const blob = new Blob([text], {type:"application/json"});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a); a.click();
  URL.revokeObjectURL(a.href); a.remove();
}
btnSave.addEventListener('click', ()=>{
  const name = prompt('Nombre del archivo (sin extensi√≥n):', 'proyecto');
  if(name===null) return;
  const safe = (name.trim() || 'proyecto').replace(/[<>:"/\\|?*\x00-\x1F]/g,'_');
  const data = serialize();
  download(safe + '.json', JSON.stringify(data,null,2));
});
btnLoad.addEventListener('click', ()=> loadInput.click());
loadInput.addEventListener('change', async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;
  try{
    const text = await file.text();
    const data = JSON.parse(text);
    loadFromData(data);
  }catch(err){
    alert('No se pudo importar el archivo.');
    console.error(err);
  }finally{
    loadInput.value = '';
  }
});
function clearAll(){
  // borra todo del lienzo
  [...connections].forEach(removeConnection);
  [...nodes].forEach(n=>removeNode(n));
  nodes=[]; connections=[];
  inputCount=outputCount=memoryCount=blockCodeCount=0;
  nextNodeId=1;

  // Update timer countdown labels
  nodes.forEach(n=>{
    if(n.type==='ton' || n.type==='toff'){
      let disp = n.el.querySelector('.timer-display');
      if(!disp){
        disp=document.createElement('div');
        disp.className='timer-display';
        n.el.appendChild(disp);
      }
      const delay = (n.delayMs ?? 1000);
      let sec = delay/1000;
      if(simulation && n.timerStart){
        const tnow = nowMs();
        let remaining = Math.max(0, delay - (tnow - n.timerStart));
        sec = remaining/1000;
      }
      disp.textContent = sec.toFixed(1) + ' s';
    }
  });

  updateConnections();
}
function loadFromData(data){
  clearAll();
  // restaurar contadores
  if(data.counts){
    inputCount=data.counts.inputCount||0;
    outputCount=data.counts.outputCount||0;
    memoryCount=data.counts.memoryCount||0;
    blockCodeCount=data.counts.blockCodeCount||0;
    nextNodeId=data.counts.nextNodeId||1;
  }
  const idMap = new Map();
  // crear nodos
  for(const n of (data.nodes||[])){
    const elType = n.type;
    createNode(elType, n.x||0, n.y||0);
    const created = nodes[nodes.length-1];
    // sobreescribir id, name, code
    created.id = n.id ?? created.id;
    if(n.name) created.name = n.name;
    if(n.code && created.code==null){
      created.code = n.code;
      // mostrar badge con el c√≥digo
      const badge=document.createElement('div'); badge.className='badge'; badge.textContent=n.code;
      created.el.appendChild(badge);
    }
    // actualizar label visible si es I/Q/M basado en contadores previos ya restaurados
    created.el.querySelector('.label').textContent = logoLabelForType(created.type).match(/^(TON|TOFF|S\/R|[&‚â•1=1‚â†1M1])$/) ? created.el.querySelector('.label').textContent : created.name;

    // restaurar delay
    if((elType==='ton' || elType==='toff') && typeof n.delayMs==='number'){
      created.delayMs = n.delayMs;
    }
    idMap.set(n.id, created);
  }
  // crear conexiones
  for(const c of (data.connections||[])){
    const fromNode = idMap.get(c.fromId);
    const toNode   = idMap.get(c.toId);
    if(!fromNode || !toNode) continue;
    const toPin = toNode.inputs[c.toIndex||0];
    createConnection(fromNode.output, toPin);
    const conn = connections[connections.length-1];
    if(c.mode==='label'){ convertWireToLabel(conn); }
  }

  // Update timer countdown labels
  nodes.forEach(n=>{
    if(n.type==='ton' || n.type==='toff'){
      let disp = n.el.querySelector('.timer-display');
      if(!disp){
        disp=document.createElement('div');
        disp.className='timer-display';
        n.el.appendChild(disp);
      }
      const delay = (n.delayMs ?? 1000);
      let sec = delay/1000;
      if(simulation && n.timerStart){
        const tnow = nowMs();
        let remaining = Math.max(0, delay - (tnow - n.timerStart));
        sec = remaining/1000;
      }
      disp.textContent = sec.toFixed(1) + ' s';
    }
  });

  updateConnections();
}

/* Init */
updateConnections();
console.log("SIMUPASIR listo: biblioteca en men√∫, guardar/importar JSON con nombre, temporizadores en segundos.");
</script> <div id="delete-debug"></div> <script>
(function(){
  const dbg = document.getElementById('delete-debug');
  const enabled = (localStorage.getItem('debugDelete') === '1');
  if (enabled) dbg.style.display = 'block';
  function logDbg(msg){
    if (!enabled) return;
    const time = new Date().toLocaleTimeString();
    dbg.innerHTML = '<b>DEL</b> ' + time + '<br>' + msg.replaceAll('\n','<br>');
  }
  window.__delDbg = logDbg;

  // Strong keydown capture
  const keyHandler = (e) => {
    // Evita borrar si est√°s escribiendo
    const el = document.activeElement;
    const typing = el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.isContentEditable);
    if (typing) return;
    if (e.key === 'Delete' || e.key === 'Backspace') {
      e.preventDefault();
      e.stopPropagation();
      __delDbg('keydown ' + e.key);
      try { deleteSelected(); } catch(err){ console.error(err); __delDbg('ERR: '+err.message); }
    }
  };
  window.addEventListener('keydown', keyHandler, true);
  document.addEventListener('keydown', keyHandler, true);

  // Defensive deleteSelected shim (keeps original if exists)
  const hasOwnDelete = (typeof window.deleteSelected === 'function');
  if (!hasOwnDelete) {
    window.deleteSelected = function(){
      if (typeof simulation !== 'undefined' && simulation) { __delDbg('bloqueado: simulation=true'); return; }
      // Prefer variables if existen
      if (typeof selectedNode !== 'undefined' && selectedNode) {
        __delDbg('delete node via selectedNode');
        if (typeof removeNode === 'function') { removeNode(selectedNode); return; }
      }
      if (typeof selectedConn !== 'undefined' && selectedConn) {
        __delDbg('delete conn via selectedConn');
        if (typeof removeConnection === 'function') { removeConnection(selectedConn); return; }
      }
      // Fallback DOM: busca algo .selected con data-type / data-id
      const el = document.querySelector('.selected,[aria-selected="true"]');
      if (el){
        const t = el.dataset.type || el.getAttribute('data-type') || el.getAttribute('data-kind');
        const id = el.dataset.id || el.getAttribute('data-id') || el.id;
        __delDbg('fallback DOM sel t='+t+' id='+id);
        if (t && /node/i.test(t) && typeof removeNodeById === 'function') { removeNodeById(id); return; }
        if (t && /(wire|conn|link|edge)/i.test(t) && typeof removeConnectionById === 'function') { removeConnectionById(id); return; }
      }
      __delDbg('nada para borrar');
    };
  }

  // Ensure button works
  const btn = document.getElementById('deleteBtn') || document.querySelector('[data-action="delete"]');
  if (btn){
    btn.addEventListener('click', (e)=>{
      __delDbg('click bot√≥n');
      try { deleteSelected(); } catch(err){ console.error(err); __delDbg('ERR:'+err.message); }
    });
  }
})();
</script> <script>
// Opcionales: remoci√≥n por ID (por si el proyecto expone arrays globales)
if (typeof removeNodeById !== 'function') {
  window.removeNodeById = function(id){
    if (!id || !Array.isArray(window.nodes)) return;
    const node = window.nodes.find(n => String(n.id) === String(id));
    if (node && typeof removeNode === 'function') removeNode(node);
  }
}
if (typeof removeConnectionById !== 'function') {
  window.removeConnectionById = function(id){
    if (!id || !Array.isArray(window.connections)) return;
    const conn = window.connections.find(c => String(c.id) === String(id));
    if (conn && typeof removeConnection === 'function') removeConnection(conn);
  }
}
</script> <script>
    // assistant-injected-pwa-and-ui
    ;(function() {
      // ==== Orientaci√≥n: abre/cierra sidebar seg√∫n landscape/portrait ====
      function getEl(id) { return document.getElementById(id) }
      const sidebar = getEl('sidebar');

      function syncSidebarToOrientation() {
        if (!sidebar) return;
        const isLandscape = window.matchMedia('(orientation: landscape)').matches;
        // Si tu UI usa la clase 'open' para el drawer, la forzamos en landscape
        sidebar.classList.toggle('open', !!isLandscape);
      }
      window.addEventListener('orientationchange', syncSidebarToOrientation);
      window.addEventListener('resize', syncSidebarToOrientation);
      document.addEventListener('DOMContentLoaded', syncSidebarToOrientation);

      // ==== Pines: facilitar tap/click cerca ====
      window.isNearTerminal = function(term, clientX, clientY, px=14){
        if (!term || !term.getBoundingClientRect) return false;
        const r = term.getBoundingClientRect();
        return (clientX >= r.left - px && clientX <= r.right + px &&
                clientY >= r.top  - px && clientY <= r.bottom + px);
      };

      // ==== Fantasmas de wires: helper opcional ====
      // Llama a purgeOrphanSVG() tras borrar conexiones si tu app expone:
      //   window.connections (array) y window.wiresSVG (SVGElement)
      window.purgeOrphanSVG = function(){
        try {
          const wiresSVG = window.wiresSVG;
          const connections = window.connections;
          if (!wiresSVG || !connections) return; // no-op si tu app no usa estos nombres

          const live = new Set();
          connections.forEach(c => {
            if (c && typeof c === 'object') {
              if (c.path) live.add(c.path);
              if (c.hit) live.add(c.hit);
              (c.handles||[]).forEach(h=> live.add(h));
              if (c.srcBranch) {
                if (c.srcBranch.path) live.add(c.srcBranch.path);
                if (c.srcBranch.hit)  live.add(c.srcBranch.hit);
              }
              if (c.dstBranch) {
                if (c.dstBranch.path) live.add(c.dstBranch.path);
                if (c.dstBranch.hit)  live.add(c.dstBranch.hit);
              }
              if (window.outputHubs && typeof window.outputHubs.get === 'function') {
                const hub = window.outputHubs.get(c.from);
                if (hub) {
                  if (hub.stemPath) live.add(hub.stemPath);
                  if (hub.dot)      live.add(hub.dot);
                  if (hub.hit)      live.add(hub.hit);
                }
              }
            }
          });
          Array.from(wiresSVG.querySelectorAll('*')).forEach(el => {
            if (!live.has(el)) el.remove();
          });
        } catch (err) {
          console.warn('purgeOrphanSVG error:', err);
        }
      };

      // Dispara purga cuando alguna parte de tu c√≥digo emita este evento:
      window.addEventListener('connection-removed', function(){
        if (window.requestIdleCallback) requestIdleCallback(window.purgeOrphanSVG);
        else setTimeout(window.purgeOrphanSVG, 0);
      });

      // ==== Registro Service Worker para PWA ====
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', function(){
          navigator.serviceWorker.register('service-worker.js').catch(console.warn);
        });
      }
    })();
    </script> <div id="editPanel" style="position:fixed;right:12px;top:58px;z-index:260;background:#ffffffcc;backdrop-filter:saturate(1.2) blur(6px);border:2px solid #003366;border-radius:12px;box-shadow:0 10px 24px rgba(0,0,0,.15);padding:12px;display:none;min-width:260px"> <div style="font-weight:900;color:#003366;margin-bottom:8px">Editar n√∫mero del bloque</div> <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px"> <div id="editPrefix" style="font-weight:900;font-size:18px;color:#003366">B</div> <input id="editNumber" min="0" step="1" style="flex:1;padding:8px;border:2px solid #bbb;border-radius:8px;font-weight:800" type="number" value="1"/> </div> <div id="editPreview" style="font-weight:900;margin:-4px 0 8px 0;color:#0f172a"></div> <div id="editError" style="font-size:12px;color:#b91c1c;display:none;margin-bottom:6px"></div> <div id="ioLabelGroup" style="display:none;margin:6px 0 10px 0"> <label style="font-weight:800;color:#003366;display:block;margin-bottom:4px">Texto superior (solo I/Q)</label> <input id="editIOLabel" placeholder="Pulsador / Piloto / L√°mpara" style="width:100%;padding:8px;border:2px solid #bbb;border-radius:8px;font-weight:700"/> <div style="font-size:12px;color:#334155;margin-top:4px">Se mostrar√° como etiqueta arriba del bloque para indicar su naturaleza.</div> <div id="inputModeGroup" style="display:none;margin:6px 0 10px 0"> <label style="font-weight:800;color:#003366;display:block;margin-bottom:4px">Comportamiento de entrada (solo I)</label> <select id="editInputMode" style="width:100%;padding:8px;border:2px solid #bbb;border-radius:8px;font-weight:800"> <option value="momentary-no">Pulsador NO (Normalmente abierto)</option> <option value="momentary-nc">Pulsador NC (Normalmente cerrado)</option> <option value="toggle">Interruptor (ON/OFF)</option> <option value="toggle-no">Interruptor NO (ON/OFF)</option> <option value="toggle-nc">Interruptor NC (ON/OFF invertido)</option> </select> <div style="font-size:12px;color:#334155;margin-top:4px"> ‚Ä¢ NO: da 1 mientras lo presionas.<br/> ‚Ä¢ NC: est√° en 1 y al presionarlo pasa a 0.<br/> ‚Ä¢ Interruptor: cambia con cada toque (se mantiene). </div> </div> </div> <div style="display:flex;gap:8px;justify-content:flex-end"> <button id="btnEditCancel" style="padding:8px 10px;border-radius:8px;border:1px solid #777;background:#fff;font-weight:800">Cancelar</button> <button id="btnEditSave" style="padding:8px 10px;border-radius:8px;border:1px solid #003366;background:#003366;color:#fff;font-weight:900">Guardar</button> </div> <div id="editHint" style="margin-top:8px;font-size:12px;color:#333">El n√∫mero no debe repetirse dentro del mismo tipo (I, Q, M o B###).</div> </div> <script>
/* === Assistant: Bot√≥n "Editar" con panel lateral, validaci√≥n de unicidad y actualizaci√≥n de etiquetas === */
(function(){
  const btnEdit = document.getElementById('btnEdit');
  const previewEl = document.getElementById('editPreview');
  const errorEl = document.getElementById('editError');
  const panel = document.getElementById('editPanel');
  const prefixEl = document.getElementById('editPrefix');
  const numberInput = document.getElementById('editNumber');
  const btnSave = document.getElementById('btnEditSave');
  const btnCancel = document.getElementById('btnEditCancel');

  function extractDigits(s){ const m=String(s||"").match(/\d+/); return m? parseInt(m[0],10): null; }
  function getNodeByEl(el){
    if(!el) return null;
    // Busca en window.nodes por .el contenedor
    if (Array.isArray(window.nodes)){
      for (const n of window.nodes){
        try{
          if(n && n.el && n.el.contains && n.el.contains(el)) return n;
        }catch(e){}
      }
    }
    // Fallback por data-node-id
    const host = el.closest?.('[data-node-id]');
    if(host){
      const nid = host.getAttribute('data-node-id');
      if (Array.isArray(window.nodes)){
        const f = window.nodes.find(nn => String(nn?.id||'')===String(nid));
        if (f) return f;
      }
    }
    return null;
  }
  function getSelectedNode(){
    // 1) Prefer global
    if (window.selectedNode && window.selectedNode.el) return window.selectedNode;
    // 2) selectedNodes array (id or object)
    if (Array.isArray(window.selectedNodes) && window.selectedNodes.length){
      const cand = window.selectedNodes[0];
      if (cand && cand.el) return cand;
      if (cand && (cand.id||cand.nodeId) && Array.isArray(window.nodes)){
        const found = window.nodes.find(n => n && (n.id===cand.id || n.id===cand.nodeId));
        if (found) return found;
      }
    }
    // 3) Scan nodes by flags / CSS
    if (Array.isArray(window.nodes)){
      const found = window.nodes.find(n => n && (n.isSelected || n.selected || (n.el && n.el.classList && n.el.classList.contains('selected'))));
      if (found) return found;
    }
    return null;
  }
  function zpad(n,len=3){ return String(n).padStart(len,'0'); }
  function currentTakenNumbersByType(exceptNode, typeKey){
  const taken = new Set();
  (window.nodes||[]).forEach(n=>{
    if(!n || n===exceptNode) return;
    let key;
    if(n.type==='input') key='I';
    else if(n.type==='output') key='Q';
    else if(n.type==='M') key='M';
    else key='B';
    if(key!==typeKey) return;
    if(key==='I' || key==='Q' || key==='M'){
      const m = String(n.name||'').match(/\d+/);
      if(m) taken.add(parseInt(m[0],10));
    } else {
      const m = String(n.code||'').match(/\d+/);
      if(m) taken.add(parseInt(m[0],10));
    }
  });
  return taken;
}

  function refreshAllTags(){
    if(!window.connections) return;
    window.connections.forEach(conn=>{
      if(conn.mode==='label'){
        try{
          if (typeof getDestNameWithPin === 'function' && conn.srcBranch && conn.srcBranch.tagEl) {
            conn.srcBranch.tagEl.textContent = getDestNameWithPin(conn);
          }
          if (typeof getSourceName === 'function' && conn.dstBranch && conn.dstBranch.tagEl) {
            conn.dstBranch.tagEl.textContent = getSourceName(conn);
          }
        }catch(e){/*no-op*/}
      }
    });
  }

  function openPanelFor(node){
    if(!node) return;
    // Determine prefix and current number
    let pref = 'B', cur = null;
    if(node.type==='input' || node.type==='output' || node.type==='M'){
      pref = node.type==='input' ? 'I' : (node.type==='output' ? 'Q' : 'M');
      cur = extractDigits(node.name);
    } else {
      pref = 'B';
      cur = extractDigits(node.code);
    }
    prefixEl.textContent = pref;
    numberInput.value = (cur ?? 1);
    numberInput.focus();
    panel.style.display = 'block';
    // Reset visuals
    numberInput.style.borderColor = '#bbb';
    errorEl.style.display='none'; errorEl.textContent='';
    previewEl.textContent = (pref==='B' ? ('B' + String(numberInput.value).padStart(3,'0')) : (pref + String(numberInput.value)));
    btnSave.disabled = false;
  }

  function closePanel(){ panel.style.display='none'; }

  btnCancel.addEventListener('click', closePanel);
  /* selection capture */
  document.addEventListener('mousedown', (e)=>{
    const node = getNodeByEl(e.target);
    if(!node) return;
    // Limpia selecci√≥n anterior visual
    try{
      if(window.selectedNode && window.selectedNode.el){ window.selectedNode.el.classList.remove('selected'); }
    }catch(_){}
    // Asigna y marca seleccionado
    window.selectedNode = node;
    try{ node.el.classList.add('selected'); }catch(_){}
  }, true);
  function validateLive(){
    const pref = prefixEl.textContent || 'B';
    const node = getSelectedNode();
    const taken = currentTakenNumbersByType(node, pref);
    const raw = String(numberInput.value||'').trim();
    let valid = /^\d+$/.test(raw);
    if(!valid){
      errorEl.style.display='block'; errorEl.textContent='Ingresa solo n√∫meros enteros.';
    }else{
      const num = parseInt(raw,10);
      if(taken.has(num)){
        valid = false;
        errorEl.style.display='block'; errorEl.textContent='Ese n√∫mero ya existe en ' + pref + '.';
      }else{
        errorEl.style.display='none'; errorEl.textContent='';
      }
    }
    // Vista previa
    const preview = (pref==='B') ? ('B' + String(raw||'0').padStart(3,'0')) : (pref + (raw||''));
    previewEl.textContent = preview;

    numberInput.style.borderColor = valid ? '#16a34a' : '#b91c1c';
    btnSave.disabled = !valid;
  }
  numberInput.addEventListener('input', validateLive);

  btnEdit?.addEventListener('click', ()=>{
    // Necesita un nodo seleccionado
    const node = getSelectedNode();
    if(!node){
      alert('Selecciona un bloque primero.');
      return;
    }
    openPanelFor(node);
  });

  btnSave.addEventListener('click', ()=>{
    const node = getSelectedNode();
    if(!node){ closePanel(); return; }
    const pref = prefixEl.textContent || 'B';
    const taken = currentTakenNumbersByType(node, pref);
    const raw = String(numberInput.value||'').trim();
    if(!/^\d+$/.test(raw)){ alert('Ingresa solo n√∫meros enteros.'); return; }
    const num = parseInt(raw,10);
    if(taken.has(num)){ alert('Ese n√∫mero ya est√° en uso por otro bloque. Elige otro.'); return; }

    if(node.type==='input' || node.type==='output' || node.type==='M'){
      const prefix = prefixEl.textContent; // I/Q/M
      node.name = prefix + String(num);
      const labelEl = node.el.querySelector('.label');
      if(labelEl) labelEl.textContent = node.name;
    }else{
      node.code = 'B' + zpad(num);
      const badgeEl = node.el.querySelector('.badge');
      if(badgeEl) badgeEl.textContent = node.code;
    }

    try{
      if(typeof updateConnections === 'function') updateConnections();
    }catch(e){}
    refreshAllTags();
    closePanel();
  });

  // Cerrar panel si se hace click fuera
  document.addEventListener('click', (e)=>{
    if(!panel || panel.style.display==='none') return;
    const inside = panel.contains(e.target) || (e.target===btnEdit);
    if(!inside) panel.style.display='none';
  }, true);

  // Exponer helpers para depuraci√≥n
  window.__editPanelHelpers = { currentTakenNumbersByType, extractDigits };
})();
</script> <script>
// === NUEVO: limpiar circuito y reiniciar numeraci√≥n ===
(function(){
  const btnNew = document.getElementById('btnNew');

  function stopSimulationIfNeeded(){
    try{
      if (typeof simulation!=='undefined' && simulation){
        simulation = false;
        if (typeof simTimer!=='undefined' && simTimer){ clearInterval(simTimer); simTimer = null; }
        document.getElementById('simulate')?.classList.remove('active');
  // reset displays
  nodes.forEach(n=>{ if(n.type==='ton'||n.type==='toff'){ const d=n.el.querySelector('.timer-display'); if(d){ const sec=((n.delayMs??1000)/1000).toFixed(1); d.textContent=sec+' s'; } } });
        document.getElementById('stop')?.classList.remove('active');
      }
    }catch(e){}
  }

  function clearAllGraphics(){
    try{
      document.querySelectorAll('.node').forEach(el => el.remove());
      document.querySelectorAll('#wires .wire-path, #wires .wire-hit, #wires .bend-hit, #wires .hub-dot, #wires .hub-hit').forEach(el => el.remove());
      document.querySelectorAll('.conn-tag').forEach(el => el.remove());
      if (typeof pendingGhost!=='undefined' && pendingGhost){ try{ pendingGhost.remove(); }catch(_){} pendingGhost = null; }
    }catch(e){}
  }

  function resetStateVariables(){
    try{
      // Estructuras
      if (typeof nodes!=='undefined') nodes.length = 0;
      if (typeof connections!=='undefined') connections.length = 0;

      // Selecciones
      if (typeof selectedNode!=='undefined' && selectedNode){ try{ selectedNode.el?.classList?.remove('selected'); }catch(_){} }
      selectedNode = null;
      selectedConn = null;
      selectedTag = null;
      selectedBranch = null;
      draggingBend = null;

      // Pines/ghost
      if (typeof selectedPinEl!=='undefined' && selectedPinEl){ try{ selectedPinEl.classList.remove('pin-selected'); }catch(_){} }
      selectedPinEl = null;
      pendingOutput = null;

      // Contadores
      inputCount = 0;
      outputCount = 0;
      memoryCount = 0;
      blockCodeCount = 0;
      nextNodeId = 1;

      // Gestos
      if (typeof longPressTimer!=='undefined' && longPressTimer){ clearTimeout(longPressTimer); longPressTimer = null; }

      // Zoom/Pan
      if (typeof scale!=='undefined'){ scale = 1; }
      if (typeof panX!=='undefined'){ panX = 0; }
      if (typeof panY!=='undefined'){ panY = 0; }
      if (typeof updateTransform==='function') updateTransform();
      if (typeof updateConnections==='function') updateConnections();
    }catch(e){}
  }

  function newCircuit(){
    const ok = confirm('¬øIniciar un circuito nuevo? Se perder√°n los cambios no guardados.');
    if (!ok) return;
    stopSimulationIfNeeded();
    if (typeof clearSelection==='function') clearSelection();
    clearAllGraphics();
    resetStateVariables();
  }

  // Click y atajo
  btnNew?.addEventListener('click', newCircuit);
  document.addEventListener('keydown', (e)=>{
    const key = (e.key || '').toLowerCase();
    if ((e.ctrlKey || e.metaKey) && key === 'n'){
      e.preventDefault();
      newCircuit();
    }
  });
})();
</script> <script src="./assets/js/main.js"></script> <script id="workarea-helper">
(function(){
  // Si tu motor usa una grilla/l√≠mites, puedes leer estas dimensiones
  // desde CSS variables:
  try {
    const root = getComputedStyle(document.documentElement);
    const W = parseInt(root.getPropertyValue('--workarea-width'));
    const H = parseInt(root.getPropertyValue('--workarea-height'));
    // Si tienes funciones de actualizaci√≥n, inv√≥calas una vez para recalcular bounds
    if (typeof updateTransform === 'function') updateTransform();
    if (typeof updateConnections === 'function') updateConnections();
  } catch(e){}
})();
</script> <script id="immersive-helper">
(function(){
  // Prevent context menu (long-press actions) on the whole app
  document.addEventListener('contextmenu', function(e){ e.preventDefault(); }, {passive:false});

  // Try to go fullscreen on first pointer interaction (required by browsers)
  let triedFS = false;
  function goFS(){
    if (triedFS) return;
    triedFS = true;
    const el = document.documentElement;
    if (el.requestFullscreen){
      el.requestFullscreen().catch(()=>{});
    } else if (el.webkitRequestFullscreen){
      el.webkitRequestFullscreen();
    }
    // Attempt orientation lock (best-effort; may fail silently)
    // orientation lock removed for free orientation (Option A));
    }
  }
  window.addEventListener('pointerdown', goFS, {once:true, passive:true});
  window.addEventListener('keydown', (e)=>{
    if ((e.key||'').toLowerCase() === 'f') goFS();
  });
})();
</script> <script id="body-app-class">document.body.classList.add("app");</script> <script id="workspace-center-once">
(function(){
  // Center only once per install/run, if pan/zoom globals exist and no prior movement
  let centered = false;
  function centerOnce(){
    if (centered) return;
    centered = true;
    try{
      // Skip if user has already panned/zoomed (heuristic)
      if (typeof panX !== 'undefined' && typeof panY !== 'undefined' && (panX !== 0 || panY !== 0)) return;
      const root = getComputedStyle(document.documentElement);
      const W = parseInt(root.getPropertyValue('--workarea-width')) || 10000;
      const H = parseInt(root.getPropertyValue('--workarea-height')) || 10000;
      const vw = window.innerWidth || document.documentElement.clientWidth;
      const vh = window.innerHeight || document.documentElement.clientHeight;
      // If we have scale variable, keep it; otherwise assume 1
      let s = (typeof scale!=='undefined' ? scale : 1);
      // Center pan so that (0,0)-(W,H) is centered
      if (typeof panX!=='undefined') panX = (vw - W * s) / 2;
      if (typeof panY!=='undefined') panY = (vh - H * s) / 2;
      if (typeof updateTransform==='function') updateTransform();
      if (typeof updateConnections==='function') updateConnections();
    }catch(e){}
  }
  // run on first interaction or when ready
  window.addEventListener('load', centerOnce, {once:true});
  window.addEventListener('orientationchange', () => { /* don't re-center after first */ }, {passive:true});
})();
</script> <script id="workspace-sizing">
(function(){
  const ws = document.getElementById('workspace');
  let svg = document.getElementById('wires');
  if(!ws) return;
  if(!svg){
    svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.id = "wires";
    svg.setAttribute("preserveAspectRatio","none");
    ws.appendChild(svg);
  }
  function cssSize(name, fallback){
    const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    const n = parseInt(v,10);
    return isNaN(n) ? fallback : n;
  }
  function applySize(){
    const S = cssSize('--workspace-size', 10000);
    svg.setAttribute('width',  S);
    svg.setAttribute('height', S);
    svg.setAttribute('viewBox', `0 0 ${S} ${S}`);
    // Si tu motor usa updateConnections/updateTransform, recalc√∫lalos
    if (typeof updateConnections === 'function') updateConnections();
    if (typeof updateTransform === 'function')   updateTransform();
  }
  applySize();
  window.addEventListener('resize', ()=>{
    // no cambiamos S en resize, pero puede forzar rec√°lculo de conexiones
    if (typeof updateConnections === 'function') updateConnections();
  });
})();
</script> <script id="tag-menu-logic">
(function(){
  'use strict';
  // Utilidad: obtener la conexi√≥n asociada a una etiqueta
  function getConnByTag(tagEl){
    try{
      if (typeof connections === 'undefined' || !Array.isArray(connections)) return null;
      for (var i=0;i<connections.length;i++){
        var c = connections[i];
        if ((c && c.srcBranch && c.srcBranch.tagEl === tagEl) || (c && c.dstBranch && c.dstBranch.tagEl === tagEl)){
          return c;
        }
      }
    }catch(e){}
    return null;
  }

  // Utilidades para eliminar etiqueta y revertir a cable
  function deleteLabelByConn(conn){

  try{
    if (!conn) return;

    // SRC branch cleanup
    if (conn.srcBranch){
      try{ conn.srcBranch.tagEl && conn.srcBranch.tagEl.remove(); }catch(e){}
      try{ conn.srcBranch.path  && conn.srcBranch.path.remove();   }catch(e){}
      try{ conn.srcBranch.hit   && conn.srcBranch.hit.remove();    }catch(e){}
      conn.srcBranch = null;
    }

    // DST branch cleanup
    if (conn.dstBranch){
      try{ conn.dstBranch.tagEl && conn.dstBranch.tagEl.remove(); }catch(e){}
      try{ conn.dstBranch.path  && conn.dstBranch.path.remove();   }catch(e){}
      try{ conn.dstBranch.hit   && conn.dstBranch.hit.remove();    }catch(e){}
      conn.dstBranch = null;
    }

    // Remove any leftover handles from label mode
    if (conn.handles && conn.handles.length){
      try{ conn.handles.forEach(h => h && h.remove && h.remove()); }catch(e){}
      conn.handles = [];
    }

    if (typeof updateConnections === 'function') updateConnections();
  }catch(e){ console.warn('deleteLabelByConn error', e); }

}


  function restoreWirePath(conn){
    try{
      var wiresSVG = document.getElementById('wires');
      if (!wiresSVG || !conn) return;
      if (conn.path && conn.path.parentNode){
        try{ conn.path.remove(); }catch(e){}
      }
      if (conn.hit && conn.hit.parentNode){
        try{ conn.hit.remove(); }catch(e){}
      }
      var path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('class','wire-path');
      var hit  = document.createElementNS('http://www.w3.org/2000/svg','path');
      hit.setAttribute('class','wire-hit');
      wiresSVG.appendChild(hit);
      wiresSVG.appendChild(path);
      conn.path = path;
      conn.hit  = hit;
      if (typeof renderConnection === 'function') {
        renderConnection(conn);
      } else if (typeof updateConnections === 'function'){
      
  // Update timer countdown labels
  nodes.forEach(n=>{
    if(n.type==='ton' || n.type==='toff'){
      let disp = n.el.querySelector('.timer-display');
      if(!disp){
        disp=document.createElement('div');
        disp.className='timer-display';
        n.el.appendChild(disp);
      }
      const delay = (n.delayMs ?? 1000);
      let sec = delay/1000;
      if(simulation && n.timerStart){
        const tnow = nowMs();
        let remaining = Math.max(0, delay - (tnow - n.timerStart));
        sec = remaining/1000;
      }
      disp.textContent = sec.toFixed(1) + ' s';
    }
  });

  updateConnections();
      }
    }catch(e){ console.warn('restoreWirePath error', e); }
  }

  function revertLabelToCable(conn){

  try{
    if (!conn) return;

    // Clear label artifacts entirely
    deleteLabelByConn(conn);

    // Switch connection back to wire mode
    conn.mode = 'wire';
    conn.srcBranch = null;
    conn.dstBranch = null;

    // Restore main wire path and its interactive hit area
    if (typeof restoreWirePath === 'function'){
      restoreWirePath(conn);
    } else if (typeof renderConnection === 'function'){
      renderConnection(conn);
    }

    // Optional: history entry if present
    try{ typeof pushHistory==='function' && pushHistory('revertir etiqueta a cable'); }catch(e){}
  }catch(e){ console.warn('revertLabelToCable error', e); }

}


  // Men√∫ de etiqueta
  var tagMenu = document.getElementById('tagMenu');
  var btnTagDelete = document.getElementById('tagDelete');
  var btnTagRevert = document.getElementById('tagRevert');
  var currentTag = null;     // tagEl activo
  var currentConn = null;    // conexi√≥n asociada

  function showTagMenuAt(x, y, tagEl){
    currentTag = tagEl;
    currentConn = getConnByTag(tagEl);
    if (!currentConn){
      hideTagMenu();
      return;
    }
    // Posicionar men√∫
    tagMenu.style.left = x + 'px';
    tagMenu.style.top  = y + 'px';
    tagMenu.style.display = 'block';

    // Cerrar por clic/tap fuera
    setTimeout(function(){
      function closeOnce(ev){
        if (!tagMenu.contains(ev.target)){
          hideTagMenu();
          document.removeEventListener('pointerdown', closeOnce, true);
          document.removeEventListener('keydown', keyClose, true);
        }
      }
      function keyClose(ev){
        if (ev.key === 'Escape'){
          hideTagMenu();
          document.removeEventListener('pointerdown', closeOnce, true);
          document.removeEventListener('keydown', keyClose, true);
        }
      }
      document.addEventListener('pointerdown', closeOnce, true);
      document.addEventListener('keydown', keyClose, true);
    }, 0);
  }
  function hideTagMenu(){
    tagMenu.style.display = 'none';
    currentTag = null;
    currentConn = null;
  }

  // Acciones
  if (btnTagDelete){
    btnTagDelete.addEventListener('click', function(){
      try{
        if (currentConn) {  try{    if (typeof removeConnection === 'function'){ removeConnection(currentConn); }    else {      try { deleteLabelByConn(currentConn); } catch(e){}      try { if(currentConn.path) currentConn.path.remove(); } catch(e){}      try { if(currentConn.hit)  currentConn.hit.remove(); } catch(e){}      try { if(Array.isArray(window.connections)){ const i=connections.indexOf(currentConn); if(i>=0) connections.splice(i,1);} } catch(e){}    }    try { if (typeof updateConnections==='function') updateConnections(); } catch(e){}    try { if (typeof purgeOrphanSVG==='function') purgeOrphanSVG(); } catch(e){}  } catch(e) { console.warn('Eliminar etiqueta+wire error', e); }}}finally{
        hideTagMenu();
      }
    });
  }
  if (btnTagRevert){
    btnTagRevert.addEventListener('click', function(){
      try{
        if (currentConn) revertLabelToCable(currentConn);
      }finally{
        hideTagMenu();
      }
    });
  }

  // Long-press y right-click sobre .conn-tag
  function enhanceOneTag(tag){
    if (!tag || tag.__ctxEnhanced) return;
    tag.__ctxEnhanced = true;

    // Right click (desktop)
    tag.addEventListener('contextmenu', function(e){
      e.preventDefault();
      showTagMenuAt(e.clientX, e.clientY, tag);
    });

    // Long-press (touch / mouse)
    var lpTimer = null;
    var startEv = null;
    function clearLP(){
      if (lpTimer){ clearTimeout(lpTimer); lpTimer = null; }
    }
    function onDown(ev){
      startEv = ev.touches ? ev.touches[0] : ev;
      clearLP();
      lpTimer = setTimeout(function(){
        var x = startEv.clientX, y = startEv.clientY;
        showTagMenuAt(x, y, tag);
      }, 600);
    }
    function onUpCancel(){
      clearLP();
    }
    tag.addEventListener('mousedown', onDown);
    tag.addEventListener('mouseup', onUpCancel);
    tag.addEventListener('mouseleave', onUpCancel);
    tag.addEventListener('touchstart', onDown, {passive:true});
    tag.addEventListener('touchend', onUpCancel);
    tag.addEventListener('touchcancel', onUpCancel);
  }

  function enhanceAllTags(){
    try{
      var tags = document.querySelectorAll('.conn-tag');
      for (var i=0;i<tags.length;i++) enhanceOneTag(tags[i]);
    }catch(e){}
  }

  // Enhance existentes al cargar
  enhanceAllTags();

  // Hook para nuevas etiquetas creadas: envolver createBranch y convertWireToLabel si existen
  try {
    if (typeof createBranch === 'function'){
      var __createBranch = createBranch;
      window.createBranch = function(args){
        var br = __createBranch(args);
        try { if (br && br.tagEl) enhanceOneTag(br.tagEl); } catch(e){}
        return br;
      };
    }
  } catch(e){}
  try {
    if (typeof convertWireToLabel === 'function'){
      var __convert = convertWireToLabel;
      window.convertWireToLabel = function(conn){
        var r = __convert(conn);
        try {
          if (conn && conn.srcBranch && conn.srcBranch.tagEl) enhanceOneTag(conn.srcBranch.tagEl);
          if (conn && conn.dstBranch && conn.dstBranch.tagEl) enhanceOneTag(conn.dstBranch.tagEl);
        } catch(e){}
        return r;
      };
    }
  } catch(e){}

  // Por si tus rutinas limpian/actualizan conexiones, re-intentar
  window.addEventListener('connection-added', enhanceAllTags);
  window.addEventListener('connection-removed', enhanceAllTags);
  window.addEventListener('connections-updated', enhanceAllTags);
})();
</script> <script id="save-load-circuit-patched">
(function(){
  let ultimoNombre = localStorage.getItem('ultimoNombreCircuito') || 'circuito';
  const btnSave = document.getElementById("btnSave") || document.getElementById("guardar") || document.getElementById("save");
  const btnLoad = document.getElementById("btnLoad") || document.getElementById("importar") || document.getElementById("load");
  let loadInput = document.getElementById("loadInput") || document.getElementById("fileJson") || document.getElementById("importFile");
  if(!btnSave || !btnLoad){
    console.warn("[PWA] Faltan botones Guardar/Importar"); return;
  }
  if(!loadInput){
    loadInput = document.createElement('input');
    loadInput.type = 'file'; loadInput.accept = 'application/json'; loadInput.id = 'loadInput'; loadInput.style.display = 'none';
    document.body.appendChild(loadInput);
  }
  function getNodes(){ try { return (typeof nodes !== 'undefined') ? nodes : (window.nodes||null); } catch(e){ return window.nodes||null; } }
  function getConnections(){ try { return (typeof connections !== 'undefined') ? connections : (window.connections||null); } catch(e){ return window.connections||null; } }
  const g = window, hasFn = (n)=> typeof g[n] === 'function';
  const NODE_W = (typeof g.NODE_W === 'number' ? g.NODE_W : 0);
  const NODE_H = (typeof g.NODE_H === 'number' ? g.NODE_H : 0);
  if (typeof g.scale === 'undefined') g.scale = 1;
  if (typeof g.panX === 'undefined') g.panX = 0;
  if (typeof g.panY === 'undefined') g.panY = 0;
  if (typeof g.inputCount === 'undefined') g.inputCount = 0;
  if (typeof g.outputCount === 'undefined') g.outputCount = 0;
  if (typeof g.memoryCount === 'undefined') g.memoryCount = 0;
  if (typeof g.blockCodeCount === 'undefined') g.blockCodeCount = 0;

  function serializeCircuit() {
    const N = getNodes(); const C = getConnections();
    if (!Array.isArray(N)) { alert("No se encontr√≥ la estructura de nodos (nodes)."); throw new Error("nodes missing"); }
    const nodeSnaps = N.map(n => {
      const x = parseFloat(n.el?.style?.left) || 0;
      const y = parseFloat(n.el?.style?.top)  || 0;
      const inputsNot = (n.inputs || []).map(inp => (inp?.dataset?.not === '1') ? 1 : 0);
      const snap = { id: n.id, type: n.type, name: n.name, code: n.code || null, x, y, inputsNot };
      if (n.type === 'ton' || n.type === 'toff') snap.delayMs = (n.delayMs ?? 1000);
      
      // Extra: persist IO label, input mode and active state
      try{
        const el = n.el;
        if (el){
          if (el.dataset && el.dataset.ioLabel){
            snap.ioLabel = el.dataset.ioLabel;
          }
          if ((n.type === 'input') && el.dataset){
            snap.inputMode = el.dataset.inputMode || el.dataset.mode || (el.dataset.nc==='true' ? 'momentary-nc' : null);
          }
          snap.active = (el.classList && el.classList.contains('active')) ? 1 : 0;
        }
      }catch(_){}
      return snap;

    });
    const connSnaps = (C || []).map(c => {
      const src = (N||[]).find(nn => nn.output === c.from);
      const dst = (N||[]).find(nn => (nn.inputs || []).includes(c.to));
      const pinIdx = dst ? (dst.inputs.indexOf(c.to) + 1) : 1;
      const base = { fromNodeId: src ? src.id : null, toNodeId: dst ? dst.id : null, toPin: pinIdx, mode: c.mode || 'wire',
                     bends: (c.bends || []).map(b => ({ x: b.x, y: b.y })) };
      if (c.mode === 'label') {
        base.srcTag = c.srcBranch ? { tx: c.srcBranch.tx, ty: c.srcBranch.ty } : null;
        base.dstTag = c.dstBranch ? { tx: c.dstBranch.tx, ty: c.dstBranch.ty } : null;
      }
      return base;
    });
    const counters = { inputCount: g.inputCount, outputCount: g.outputCount, memoryCount: g.memoryCount, blockCodeCount: g.blockCodeCount };
    const view = { scale: g.scale, panX: g.panX, panY: g.panY };
    return { v: 2, nodes: nodeSnaps, connections: connSnaps, counters, view };
  }

  function resetCircuitCanvas() {
    try { g.clearSelection && g.clearSelection(); } catch(_){}
    document.querySelectorAll('.wire-path,.wire-hit,.hub-dot,.hub-hit,.conn-tag').forEach(el => el.remove());
    const N = getNodes(); const C = getConnections();
    if (Array.isArray(N)) N.forEach(n => n.el?.remove());
    if (Array.isArray(N)) N.length = 0;
    if (Array.isArray(C)) C.length = 0;
    try { if (g.outputHubs?.clear) g.outputHubs.clear(); } catch(_){}
    if (typeof g.inputCount  !== 'undefined') g.inputCount  = 0;
    if (typeof g.outputCount !== 'undefined') g.outputCount = 0;
    if (typeof g.memoryCount !== 'undefined') g.memoryCount = 0;
    if (typeof g.blockCodeCount !== 'undefined') g.blockCodeCount = 0;
    if (typeof g.nextNodeId !== 'undefined') g.nextNodeId = 1;
  }

  function deserializeCircuit(obj) {
    if (!obj || !Array.isArray(obj.nodes)) throw new Error('Archivo inv√°lido');
    resetCircuitCanvas();
    if (obj.counters) {
      if (typeof obj.counters.inputCount === 'number') g.inputCount = obj.counters.inputCount;
      if (typeof obj.counters.outputCount === 'number') g.outputCount = obj.counters.outputCount;
      if (typeof obj.counters.memoryCount === 'number') g.memoryCount = obj.counters.memoryCount;
      if (typeof obj.counters.blockCodeCount === 'number') g.blockCodeCount = obj.counters.blockCodeCount;
    }
    const idMap = new Map();
    (obj.nodes || []).forEach(ns => {
      if (!hasFn('createNode')) throw new Error('createNode no disponible');
      const cx = ns.x + (NODE_W/2), cy = ns.y + (NODE_H/2);
      g.createNode(ns.type, cx, cy);
      const N = getNodes(); const n = N[N.length - 1];
      n.id = ns.id; n.name = ns.name;
      if (ns.code) { n.code = ns.code; const badge = n.el?.querySelector?.('.badge'); if (badge) badge.textContent = ns.code; }
      (n.inputs || []).forEach((inp, i) => {
        const shouldNot = (ns.inputsNot && ns.inputsNot[i] === 1);
        if (shouldNot && !inp.classList.contains('not')) { inp.classList.add('not'); inp.dataset.not = '1'; }
      });
      (n.inputs || []).forEach((inp, i) => {
        const shouldNot = (ns.inputsNot && ns.inputsNot[i] === 1);
        if (shouldNot && !inp.classList.contains('not')) { inp.classList.add('not'); inp.dataset.not = '1'; }
      });
      
      // Restore IO label (I/Q)
      try{
        if (typeof ns.ioLabel === 'string' && ns.ioLabel){
          n.el.dataset.ioLabel = ns.ioLabel;
          if (typeof ensureIOBadge === 'function') ensureIOBadge(n.el);
        }
      }catch(_){}
      // Restore inputMode for inputs
      try{
        if (n.type === 'input' && ns.inputMode){
          n.el.dataset.inputMode = ns.inputMode;
          if (window.attachInputModeBehavior) window.attachInputModeBehavior(n, true);
        }
      }catch(_){}
      // Restore active state
      try{
        if (ns.active){
          n.el.classList.add('active');
          if ('value' in n) n.value = 1;
        } else {
          n.el.classList.remove('active');
        }
      }catch(_){}
if ((n.type === 'ton' || n.type === 'toff') && typeof ns.delayMs === 'number') { n.delayMs = ns.delayMs; n.timerStart = null; n.prevIn = 0; if (n.type === 'toff') n.seenHigh = false; }
      idMap.set(ns.id, n);
    });
    (obj.connections || []).forEach(cs => {
      const src = idMap.get(cs.fromNodeId), dst = idMap.get(cs.toNodeId);
      if (!src || !dst) return;
      const toPinIdx = Math.max(1, Math.min((dst.inputs||[]).length, cs.toPin || 1)) - 1;
      const fromTerm = src.output, toTerm = dst.inputs[toPinIdx];
      if (!fromTerm || !toTerm) return;
      if (!hasFn('createConnection')) return;
      g.createConnection(fromTerm, toTerm);
      const C = getConnections(); const conn = C[C.length - 1];
      conn.bends = Array.isArray(cs.bends) ? cs.bends.map(b => ({ x: b.x, y: b.y })) : [];
      if (hasFn('renderConnection')) g.renderConnection(conn);
      if (cs.mode === 'label' && hasFn('convertWireToLabel')) {
        g.convertWireToLabel(conn);
        if (cs.srcTag && conn.srcBranch) { conn.srcBranch.tx = cs.srcTag.tx; conn.srcBranch.ty = cs.srcTag.ty; g.renderBranch && g.renderBranch(conn.srcBranch); }
        if (cs.dstTag && conn.dstBranch) { conn.dstBranch.tx = cs.dstTag.tx; conn.dstBranch.ty = cs.dstTag.ty; g.renderBranch && g.renderBranch(conn.dstBranch); }
      }
    });
    if (obj.view) { if (typeof obj.view.scale === 'number') g.scale = obj.view.scale; if (typeof obj.view.panX === 'number') g.panX = obj.view.panX; if (typeof obj.view.panY === 'number') g.panY = obj.view.panY; }
    if (hasFn('updateTransform')) g.updateTransform();
    if (hasFn('updateConnections')) g.updateConnections();
  }

  function downloadJSON(obj, filename='circuito.json') {
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type:'application/json' });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename;
    document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
  }

  btnSave.addEventListener('click', () => { try { const data = serializeCircuit(); let nombre = prompt('Escribe el nombre del archivo:', ultimoNombre); if (!nombre) return; if (!nombre.toLowerCase().endsWith('.json')) nombre += '.json'; localStorage.setItem('ultimoNombreCircuito', nombre); downloadJSON(data, nombre); } catch (e) { alert('No se pudo guardar: ' + e.message); } });
  btnLoad.addEventListener('click', () => { const input = document.getElementById("loadInput") || loadInput; input.value=''; input.click(); });
  (document.getElementById("loadInput") || loadInput).addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0]; if (!file) return;
    try { const text = await file.text(); const obj = JSON.parse(text); deserializeCircuit(obj); }
    catch(err){ alert('Archivo inv√°lido o corrupto.'); }
  });
})();
</script> <script>
/* === Assistant: IO label integration for I/Q blocks === */
(function(){
  

function ensureIOBadge(el){
  if(!el) return;
  const t = (el.dataset?.type || '').toLowerCase();
  const isIO = (t==='input' || t==='output');
  let badge = el.querySelector('.io-badge');
  const txt = (el.dataset.ioLabel || '').trim();
  if(!isIO || !txt){
    if(badge) badge.remove();
    el.classList.remove('has-io-badge');
    return;
  }
  if(!badge){
    badge = document.createElement('div');
    badge.className = 'io-badge';
    el.appendChild(badge);
  }
  badge.textContent = txt;
  el.classList.add('has-io-badge');
}

  if(!title){
    title = document.createElement('div');
    title.className = 'io-badge';
    el.appendChild(title);
  }
  title.textContent = txt;      // solo texto
  el.classList.add('has-io-badge');
}

    //
      title = document.createElement('div');
      title.className = 'io-badge';
      el.appendChild(title);
    }
    const def = t==='input' ? 'Pulsador' : 'Piloto';
    title.textContent = (el.dataset.ioLabel && el.dataset.ioLabel.trim()) ? el.dataset.ioLabel.trim() : def;
    el.classList.add('has-io-badge');
  }
  function refreshAllIOTitles(){
    document.querySelectorAll('.node').forEach(el=> ensureIOBadge(el));
  }
  // Initialize for current nodes
  if(document.readyState!=='loading') refreshAllIOTitles();
  else document.addEventListener('DOMContentLoaded', refreshAllIOTitles);

  // Observe future nodes
  const ws = document.getElementById('workspace') || document.body;
  const mo = new MutationObserver((mrs)=>{
    for(const mr of mrs){
      mr.addedNodes && mr.addedNodes.forEach(n=>{
        if(n.nodeType===1){
          if(n.classList.contains('node')) ensureIOBadge(n);
          n.querySelectorAll && n.querySelectorAll('.node').forEach(ensureIOBadge);
        }
      });
    }
  });
  mo.observe(ws, {childList:true, subtree:true});

  // Hook edit panel
  const panel = document.getElementById('editPanel');
  const ioGroup = document.getElementById('ioLabelGroup');
  const ioInput = document.getElementById('editIOLabel');
  const prefixEl = document.getElementById('editPrefix');
  const numberInput = document.getElementById('editNumber');
  const btnSave = document.getElementById('btnEditSave');

  function getSelectedNode(){
    if (window.selectedNode && window.selectedNode.el) return window.selectedNode;
    // Fallback: try to find by .selected class
    const sel = document.querySelector('.node.selected');
    if(sel && Array.isArray(window.nodes)){
      const found = window.nodes.find(n=>n && n.el===sel);
      if(found) return found;
    }
    return null;
  }

  // Show/hide IO field when panel opens
  const openObserver = new MutationObserver(()=>{
    if(!panel) return;
    const isOpen = panel.style && panel.style.display!=='none';
    if(!isOpen) return;
    const node = getSelectedNode();
    const pref = (prefixEl?.textContent||'').trim();
    const isIO = (pref==='I' || pref==='Q' || (node && (node.type==='input' || node.type==='output')));
    if(ioGroup) ioGroup.style.display = isIO ? 'block' : 'none';
    if(isIO && ioInput){
      let el = node?.el;
      ioInput.value = (el?.dataset?.ioLabel || '');
    }
  });
  openObserver.observe(panel, {attributes:true, attributeFilter:['style']});

  // Save hook: persist ioLabel into dataset and refresh title
  if(btnSave){
    btnSave.addEventListener('click', function(){
      const node = getSelectedNode();
      if(!node || !node.el) return;
      const t = (node.type||'').toLowerCase();
      if(t==='input' || t==='output'){
        if(ioInput && typeof ioInput.value === 'string'){
          const val = (ioInput.value || '').trim();
          if(val){ node.el.dataset.ioLabel = val; }
          else{ delete node.el.dataset.ioLabel; }
          ensureIOBadge(node.el);
        }
      }
    }, {capture:true});
  }

  // Expose for debugging
  window.__ioLabelHelpers = { ensureIOBadge };
})();
</script> <script>
// === Assistant: Ensure IO text field shows for I/Q on Edit ===
(function(){
  const panel = document.getElementById('editPanel');
  const ioGroup = document.getElementById('ioLabelGroup');
  const ioInput = document.getElementById('editIOLabel');
  const prefixEl = document.getElementById('editPrefix');
  const numberInput = document.getElementById('editNumber');
  function getSelectedNode(){
    if (window.selectedNode && window.selectedNode.el) return window.selectedNode;
    const sel = document.querySelector('.node.selected');
    if(sel && Array.isArray(window.nodes)){
      const found = window.nodes.find(n=>n && n.el===sel);
      if(found) return found;
    }
    return null;
  }
  function updateIOGroupVisibility(){
    if(!panel || !ioGroup) return;
    const node = getSelectedNode();
    const pref = (prefixEl?.textContent||'').trim();
    const isIO = (pref==='I' || pref==='Q' || (node && (node.type==='input' || node.type==='output')));
    ioGroup.style.display = isIO ? 'block' : 'none';
    if(isIO && ioInput){
      const el = node?.el;
      ioInput.value = (el?.dataset?.ioLabel || '');
    }
  }
  // Try to hook Edit button if present
  const be = document.getElementById('btnEdit');
  if(be){
    be.addEventListener('click', function(){
      setTimeout(updateIOGroupVisibility, 0);
      setTimeout(updateIOGroupVisibility, 30);
    }, true);
  }
  // Also observe panel display changes
  const mo = new MutationObserver(()=>{
    const isOpen = panel && panel.style && panel.style.display !== 'none';
    if(isOpen) updateIOGroupVisibility();
  });
  if(panel) mo.observe(panel, {attributes:true, attributeFilter:['style']});
  window.__ioEditFieldDebug = { updateIOGroupVisibility };
})();
</script> <script>
/* === Assistant: Safety hook to ALWAYS persist & render IO text on Save === */
(function(){
  function getSelectedNode(){
    if (window.selectedNode && window.selectedNode.el) return window.selectedNode;
    const sel = document.querySelector('.node.selected');
    if(sel && Array.isArray(window.nodes)){
      const found = window.nodes.find(n=>n && n.el===sel);
      if(found) return found;
    }
    return null;
  }
  function ensureIOBadge(el){
    if(!el) return;
    const t = (el.dataset?.type || '').toLowerCase();
    const isIO = (t==='input' || t==='output');
    let badge = el.querySelector('.io-badge');
    const txt = (el.dataset.ioLabel || '').trim();
    if(!isIO || !txt){
      if(badge) badge.remove();
      el.classList.remove('has-io-badge');
      return;
    }
    if(!badge){
      badge = document.createElement('div');
      badge.className = 'io-badge';
      el.appendChild(badge);
    }
    badge.textContent = txt;
    el.classList.add('has-io-badge');
  }
  const saveBtn = document.getElementById('btnEditSave');
  const ioInput = document.getElementById('editIOLabel');
  if(saveBtn && ioInput){
    // Run AFTER other listeners
    saveBtn.addEventListener('click', function(){
      setTimeout(function(){
        const node = getSelectedNode();
        if(!node || !node.el) return;
        const val = (ioInput.value||'').trim();
        if(val){ node.el.dataset.ioLabel = val; } else { delete node.el.dataset.ioLabel; }
        ensureIOBadge(node.el);
      }, 0);
    }, false);
  }
})();
</script> <style>
.junction-dot{ fill:#000; stroke:#000; stroke-width:3 }
</style> <script>
(function(){
  if (window.__junctionsV32) return;
  window.__junctionsV32 = true;

  const wiresSVG = document.getElementById('wires');
  if (!wiresSVG) return;

  const TOL = 2.5;
  const near = (a,b,t=TOL)=>Math.abs(a-b)<=t;
  const nearPt = (A,B)=>A&&B&&near(A.x,B.x)&&near(A.y,B.y);

  // Layer for dots
  let layer = wiresSVG.querySelector('g[data-layer="junctions"]');
  if (!layer){
    layer = document.createElementNS("http://www.w3.org/2000/svg","g");
    layer.setAttribute("data-layer","junctions");
    wiresSVG.appendChild(layer);
  }

  const dots = new Map();
  const keyFor = (x,y)=>Math.round(x)+'|'+Math.round(y);
  function placeDot(x,y){
    const k = keyFor(x,y);
    let c = dots.get(k);
    if (!c){
      c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute('r', 10);
      c.setAttribute('class','junction-dot');
      layer.appendChild(c);
      dots.set(k,c);
    }
    c.setAttribute('cx', x); c.setAttribute('cy', y);
    return c;
  }
  function clearDots(){ for (const c of dots.values()) c.remove(); dots.clear(); }

  function getWirePaths(){ return Array.from(wiresSVG.querySelectorAll('path.wire-path')); }

  // Parse "M/L" polyline points
  function parseVerts(pathEl){
    try{
      const d = pathEl.getAttribute('d') || '';
      const nums = d.replace(/[MLZmlz]/g,' ').trim().split(/[\s,]+/).map(Number).filter(n=>!Number.isNaN(n));
      const v = [];
      for (let i=0;i+1<nums.length;i+=2) v.push({x:nums[i], y:nums[i+1]});
      if (!v.length){
        const len = pathEl.getTotalLength();
        const p0 = pathEl.getPointAtLength(0), p1 = pathEl.getPointAtLength(len);
        v.push({x:p0.x,y:p0.y},{x:p1.x,y:p1.y});
      }
      return v;
    }catch(_){ return []; }
  }

  function onSeg(pt,a,b){
    // axis-aligned check: pt on segment ab with tolerance
    if (near(a.x,b.x)){ // vertical
      if (!near(pt.x,a.x)) return false;
      const miny = Math.min(a.y,b.y)-TOL, maxy = Math.max(a.y,b.y)+TOL;
      return pt.y>=miny && pt.y<=maxy;
    }else if (near(a.y,b.y)){ // horizontal
      if (!near(pt.y,a.y)) return false;
      const minx = Math.min(a.x,b.x)-TOL, maxx = Math.max(a.x,b.x)+TOL;
      return pt.x>=minx && pt.x<=maxx;
    }
    return false;
  }
  function pointOnPolyline(pt, poly){
    for (let i=0;i+1<poly.length;i++){
      if (onSeg(pt, poly[i], poly[i+1])) return true;
    }
    return false;
  }
  function segIntersect(a1,a2,b1,b2){
    // axis-aligned segment intersection with tolerance
    // horizontal vs vertical only expected
    const horiz = near(a1.y,a2.y) ? [a1,a2] : (near(b1.y,b2.y) ? [b1,b2] : null);
    const vert  = near(a1.x,a2.x) ? [a1,a2] : (near(b1.x,b2.x) ? [b1,b2] : null);
    if (!horiz || !vert) return null;
    const y = horiz[0].y, x = vert[0].x;
    const minx = Math.min(horiz[0].x,horiz[1].x)-TOL, maxx = Math.max(horiz[0].x,horiz[1].x)+TOL;
    const miny = Math.min(vert[0].y,vert[1].y)-TOL, maxy = Math.max(vert[0].y,vert[1].y)+TOL;
    if (x>=minx && x<=maxx && y>=miny && y<=maxy) return {x,y};
    return null;
  }
  function polylineIntersectPoint(polyA, polyB){
    for (let i=0;i+1<polyA.length;i++){
      for (let j=0;j+1<polyB.length;j++){
        const p = segIntersect(polyA[i], polyA[i+1], polyB[j], polyB[j+1]);
        if (p) return p;
      }
    }
    return null;
  }

  function groupByStart(paths){
    const groups=[]; const used=new Set();
    for (let i=0;i<paths.length;i++){
      if (used.has(i)) continue;
      const vi = parseVerts(paths[i]); if (!vi.length) continue;
      const s = vi[0];
      const g=[{el:paths[i], verts:vi}]; used.add(i);
      for (let j=i+1;j<paths.length;j++){
        if (used.has(j)) continue;
        const vj = parseVerts(paths[j]); if (!vj.length) continue;
        if (nearPt(s, vj[0])){ g.push({el:paths[j], verts:vj}); used.add(j); }
      }
      groups.push(g);
    }
    return groups;
  }

  function lastCommonVertex(A,B){
    const n = Math.min(A.length,B.length);
    let last = A[0];
    for (let i=0;i<n;i++){
      if (nearPt(A[i],B[i])) last = A[i]; else break;
    }
    return last;
  }

  let raf=0, obs=null;
  function refresh(){
    if (obs) obs.disconnect();
    try{
      clearDots();
      const paths = getWirePaths();
      if (!paths.length) return;
      const groups = groupByStart(paths);
      for (const g of groups){
        if (g.length < 2) continue;
        const ref = g[0];
        for (let k=1;k<g.length;k++){
          const A = ref.verts, B = g[k].verts;
          // 1) Prefer the first corner of B if it lies on A (true T at branch)
          const cornerB = B[1];
          if (cornerB && pointOnPolyline(cornerB, A)){ placeDot(cornerB.x, cornerB.y); continue; }
          // 2) Or the first corner of A if it lies on B
          const cornerA = A[1];
          if (cornerA && pointOnPolyline(cornerA, B)){ placeDot(cornerA.x, cornerA.y); continue; }
          // 3) Else compute any intersection between polylines
          const X = polylineIntersectPoint(A,B);
          if (X){ placeDot(X.x, X.y); continue; }
          // 4) Fallback to last common vertex (may be start if nothing else matches)
          const L = lastCommonVertex(A,B);
          if (L) placeDot(L.x, L.y);
        }
      }
    }finally{
      if (initObserver) initObserver();
    }
  }
  function schedule(){ if (!raf) raf = requestAnimationFrame(()=>{ raf=0; refresh(); }); }

  function initObserver(){
    try{
      obs = new MutationObserver((muts)=>{
        const relevant = muts.some(m=> (m.type==='childList' && (m.addedNodes.length||m.removedNodes.length)) || (m.type==='attributes' && m.attributeName==='d'));
        if (relevant) schedule();
      });
      obs.observe(wiresSVG, {subtree:true, childList:true, attributes:true, attributeFilter:['d']});
    }catch(_){}
  }

  const _update = window.updateConnections;
  window.updateConnections = function(){
    if (typeof _update==='function') _update.apply(this, arguments);
    schedule();
  };

  window.addEventListener('resize', schedule);
  window.addEventListener('DOMContentLoaded', schedule);
  initObserver();
  schedule();
})();
</script> <script id="input-modes-logic">
(function(){
  'use strict';
  function getNodes(){ try { return (typeof nodes!=='undefined') ? nodes : (window.nodes||[]); } catch(e){ return window.nodes||[]; } }
  function getSelectedNode(){
    if (window.selectedNode && window.selectedNode.el) return window.selectedNode;
    const sel = document.querySelector('.node.selected');
    const arr = getNodes();
    if (sel && Array.isArray(arr)){
      const found = arr.find(n=>n && n.el===sel);
      if (found) return found;
    }
    return null;
  }

  // Core: attach event behavior according to dataset.inputMode
  window.attachInputModeBehavior = function(node, forceResetDefault){
    try{
      if(!node || !node.el || node.type!=='input') return;
      const el = node.el;
      const mode = (el.dataset.inputMode || 'momentary-no');

      
      var minOnUntil=0, pendingOff=null; // assistant: 500ms min pulse
// Remove previous listeners (if any)
      if (el.__im_down){ el.removeEventListener('pointerdown', el.__im_down); el.__im_down = null; }
      if (el.__im_up){ el.removeEventListener('pointerup', el.__im_up); el.__im_up = null; }
      if (el.__im_leave){ el.removeEventListener('pointerleave', el.__im_leave); el.__im_leave = null; }
      if (el.__im_cancel){ el.removeEventListener('pointercancel', el.__im_cancel); el.__im_cancel = null; }
      if (el.__im_click){ el.removeEventListener('click', el.__im_click); el.__im_click = null; }
      // Also on touch
      if (el.__im_tstart){ el.removeEventListener('touchstart', el.__im_tstart); el.__im_tstart=null; }
      if (el.__im_tend){ el.removeEventListener('touchend', el.__im_tend); el.__im_tend=null; }
      if (el.__im_tcancel){ el.removeEventListener('touchcancel', el.__im_tcancel); el.__im_tcancel=null; }

      function setActive(v){
        if(v){ el.classList.add('active'); }
        else { el.classList.remove('active'); }
      }

      // Default visual state for each mode
      function applyDefault(){
        if (mode==='momentary-no'){ setActive(false); }
        else if (mode==='momentary-nc'){ setActive(true); }
        else if (mode==='toggle' || mode==='toggle-no' || mode==='toggle-nc'){ /* keep as-is */ }
      }

      if (forceResetDefault) applyDefault();

      if (mode==='toggle' || mode==='toggle-no' || mode==='toggle-nc'){
        el.__im_click = function(e){ e.stopPropagation(); setActive(!el.classList.contains('active')); };
        el.addEventListener('click', el.__im_click);
      } else if (mode==='momentary-no'){
        el.__im_down = function(e){ e.stopPropagation(); setActive(true); minOnUntil=(performance&&performance.now?performance.now():Date.now())+500; if(pendingOff){try{clearTimeout(pendingOff);}catch(_){}}};
        el.__im_up = function(){ var __now=(performance&&performance.now?performance.now():Date.now()); var __rem=Math.max(0, minOnUntil-__now); if(pendingOff){try{clearTimeout(pendingOff);}catch(_){}} pendingOff=setTimeout(function(){ setActive(false); }, __rem); };
        el.__im_leave = function(){ var __now=(performance&&performance.now?performance.now():Date.now()); var __rem=Math.max(0, minOnUntil-__now); if(pendingOff){try{clearTimeout(pendingOff);}catch(_){}} pendingOff=setTimeout(function(){ setActive(false); }, __rem); };
        el.__im_cancel = function(){ var __now=(performance&&performance.now?performance.now():Date.now()); var __rem=Math.max(0, minOnUntil-__now); if(pendingOff){try{clearTimeout(pendingOff);}catch(_){}} pendingOff=setTimeout(function(){ setActive(false); }, __rem); };
        el.addEventListener('pointerdown', el.__im_down);
        el.addEventListener('pointerup', el.__im_up);
        el.addEventListener('pointerleave', el.__im_leave);
        el.addEventListener('pointercancel', el.__im_cancel);
        el.__im_tstart = function(){ setActive(true); };
        el.__im_tend = function(){ setActive(false); };
        el.__im_tcancel = function(){ setActive(false); };
        el.addEventListener('touchstart', el.__im_tstart, {passive:true});
        el.addEventListener('touchend', el.__im_tend);
        el.addEventListener('touchcancel', el.__im_tcancel);
      } else if (mode==='momentary-nc'){
        el.__im_down = function(e){ e.stopPropagation(); setActive(false); minOnUntil=(performance&&performance.now?performance.now():Date.now())+500; if(pendingOff){try{clearTimeout(pendingOff);}catch(_){}}};
        el.__im_up = function(){ var __now=(performance&&performance.now?performance.now():Date.now()); var __rem=Math.max(0, minOnUntil-__now); if(pendingOff){try{clearTimeout(pendingOff);}catch(_){}} pendingOff=setTimeout(function(){ setActive(true); }, __rem); };
        el.__im_leave = function(){ var __now=(performance&&performance.now?performance.now():Date.now()); var __rem=Math.max(0, minOnUntil-__now); if(pendingOff){try{clearTimeout(pendingOff);}catch(_){}} pendingOff=setTimeout(function(){ setActive(true); }, __rem); };
        el.__im_cancel = function(){ var __now=(performance&&performance.now?performance.now():Date.now()); var __rem=Math.max(0, minOnUntil-__now); if(pendingOff){try{clearTimeout(pendingOff);}catch(_){}} pendingOff=setTimeout(function(){ setActive(true); }, __rem); };
        el.addEventListener('pointerdown', el.__im_down);
        el.addEventListener('pointerup', el.__im_up);
        el.addEventListener('pointerleave', el.__im_leave);
        el.addEventListener('pointercancel', el.__im_cancel);
        el.__im_tstart = function(){ setActive(false); };
        el.__im_tend = function(){ setActive(true); };
        el.__im_tcancel = function(){ setActive(true); };
        el.addEventListener('touchstart', el.__im_tstart, {passive:true});
        el.addEventListener('touchend', el.__im_tend);
        el.addEventListener('touchcancel', el.__im_tcancel);
      }
    }catch(e){ console.warn('attachInputModeBehavior error', e); }
  };

  // Hook: when creating an input node, ensure dataset + behavior
  // We'll patch nodes.push(node) site to call us, but also handle existing nodes on load:
  window.addEventListener('load', function(){
    try{
      const arr = getNodes();
      if (Array.isArray(arr)){
        arr.forEach(n=>{
          if (n && n.type==='input'){
            const el = n.el;
            if (el && !el.dataset.inputMode) el.dataset.inputMode = 'momentary-no';
            window.attachInputModeBehavior(n, true);
          }
        });
      }
    }catch(_){};
  });

  // === Edit panel integration ===
  (function(){
    const panel = document.getElementById('editPanel');
    const modeGroup = document.getElementById('inputModeGroup');
    const modeSelect = document.getElementById('editInputMode');
    const prefixEl = document.getElementById('editPrefix');
    const btnSave = document.getElementById('btnEditSave');

    function showHide(){
      if (!panel || !modeGroup) return;
      const pref = (prefixEl?.textContent||'').trim();
      const node = getSelectedNode();
      const isInput = (pref==='I' || (node && node.type==='input'));
      modeGroup.style.display = isInput ? 'block' : 'none';
      if (isInput && modeSelect && node && node.el){
        // load current value
        let __m = node.el.dataset.inputMode || 'momentary-no';
        if (__m==='toggle') __m='toggle-no';
        modeSelect.value = __m;
      }
    }

    // Observe panel opening
// Apply input mode immediately when changed in Edit panel (safe minimal patch)
(function(){
  const panel = document.getElementById('editPanel');
  const modeSelect = document.getElementById('editInputMode');
  if(!panel || !modeSelect) return;
  function getSelectedNode(){
    if (window.selected && window.selected.el) return window.selected;
    const el = document.querySelector('.node.selected');
    if(!el) return null;
    const id = parseInt(el.dataset.id||el.getAttribute('data-id')||'0',10);
    if (isNaN(id)) return null;
    return (window.nodes||[]).find(nn=>nn && nn.id===id) || null;
  }
  modeSelect.addEventListener('change', function(){
    const node = getSelectedNode();
    if(!node || node.type!=='input' || !node.el) return;
    node.el.dataset.inputMode = modeSelect.value || 'momentary-no';
    if(window.attachInputModeBehavior) window.attachInputModeBehavior(node, true);
  });
})();

    const mo = new MutationObserver(showHide);
    if (panel) mo.observe(panel, {attributes:true, attributeFilter:['style']});
    // Also try when Edit button clicked
    const be = document.getElementById('btnEdit');
    if (be) be.addEventListener('click', ()=>{ setTimeout(showHide, 0); setTimeout(showHide, 50); }, true);

    // Save mode along with number/labels
    if (btnSave && modeSelect){
      btnSave.addEventListener('click', function(){
        const node = getSelectedNode();
        if (!node || !node.el) return;
        if (node.type === 'input'){
          node.el.dataset.inputMode = modeSelect.value || 'momentary-no';
          window.attachInputModeBehavior(node, true);
        }
      }, {capture:true});
    }
  })();

  // On stop/reset, re-apply defaults for NC / NO
  (function(){
    const stopBtn = document.getElementById('stop');
    if (stopBtn){
      stopBtn.addEventListener('click', function(){
        try{
          const arr = getNodes();
          arr && arr.forEach(n=>{
            if (n && n.type==='input'){
              window.attachInputModeBehavior(n, true);
            }
          });
        }catch(e){}
      }, {capture:true});
    }
  })();

  // Patch serialize to include inputMode, if present
  try{
    const __serialize = window.serialize;
    if (typeof __serialize === 'function'){
      window.serialize = function(){
        const data = __serialize();
        try{
          if (Array.isArray(data.nodes)){
            data.nodes.forEach(function(n){
              try{
                if (n.type==='input'){
                  // We need to locate the live node by id to read dataset
                  const live = (window.nodes||[]).find(nn=>nn && nn.id===n.id);
                  const mode = live && live.el && live.el.dataset ? live.el.dataset.inputMode : null;
                  if (mode) n.inputMode = mode;
                }
              }catch(_){}
            });
          }
        }catch(_){}
        return data;
      };
    }
  }catch(_){}

  // Patch loadFromData to restore inputMode
  try{
    const __load = window.loadFromData;
    if (typeof __load === 'function'){
      window.loadFromData = function(data){
        __load(data);
        try{
          // After loading, data.nodes exists; apply inputMode to created nodes by id
          if (data && Array.isArray(data.nodes) && Array.isArray(window.nodes)){
            data.nodes.forEach(dn => {
              if (dn && dn.type==='input' && dn.inputMode){
                const live = window.nodes.find(nn=>nn && nn.id===dn.id);
                if (live && live.el){
                  live.el.dataset.inputMode = dn.inputMode;
                  window.attachInputModeBehavior(live, true);
                }
              }
            });
          }
        }catch(e){}
      };
    }
  }catch(_){}

})();
</script> <script>
(function(){
  function setSplash(active){
    const body = document.body;
    const overlay = document.getElementById('splashOverlay');
    const buttons = [
      document.getElementById('simulate'),
      document.getElementById('stop'),
      document.getElementById('btnSave'),
      document.getElementById('btnLoad'),
      document.getElementById('btnEdit'),
      document.getElementById('deleteBtn')
    ];
    if(active){
      if(overlay) overlay.style.display = 'flex';
      body.classList.add('splash');
      buttons.forEach(b => { if(b) { b.dataset.wasDisabled = b.disabled ? '1':'0'; b.disabled = true; } });
    }else{
      if(overlay) overlay.style.display = 'none';
      body.classList.remove('splash');
      buttons.forEach(b => { if(b && b.dataset) { b.disabled = (b.dataset.wasDisabled==='1'); delete b.dataset.wasDisabled; } });
    }
  }

  // Activate splash on load
  window.addEventListener('DOMContentLoaded', function(){
    setSplash(true);
  });

  // When user clicks "Nuevo", exit splash and let existing 'Nuevo' behavior run
  const btnNew = document.getElementById('btnNew');
  if(btnNew){
    btnNew.addEventListener('click', function onFirstNew(){
      setSplash(false);
      // Only remove this temporary listener; keep any existing ones bound elsewhere
      btnNew.removeEventListener('click', onFirstNew);
    });
  }
})();
</script> <script id="logicsoft-two-themes-controller">
(function(){
  var KEY = 'logicsoft.theme.two';        // 'original' | 'logosoft'
  var root = document.documentElement;

  function apply(name){
    // Original: sin clase; LOGOSOFT: agrega la clase
    if(name === 'logosoft'){
      root.classList.add('theme-logosoft');
    } else {
      root.classList.remove('theme-logosoft');
      name = 'original';
    }
    try{ localStorage.setItem(KEY, name); }catch(e){}
    var btn = document.getElementById('themeBtnTwo');
    if(btn){
      btn.title = 'Tema: ' + (name === 'logosoft' ? 'LOGOSOFT' : 'Original');
      btn.setAttribute('aria-label', btn.title);
      btn.textContent = (name === 'logosoft' ? 'üßÅ' : 'üé®'); // icono distinto para feedback
    }
  }

  function next(curr){ return (curr === 'logosoft') ? 'original' : 'logosoft'; }

  // Init
  var saved = 'original';
  try{ saved = localStorage.getItem(KEY) || 'original'; }catch(e){}
  apply(saved);

  // Button
  var btn = document.getElementById('themeBtnTwo');
  if(btn){
    btn.addEventListener('click', function(){
      var now = next(localStorage.getItem(KEY) || 'original');
      apply(now);
      btn.animate([{transform:'scale(1)'},{transform:'scale(.9)'},{transform:'scale(1)'}], {duration:160});
    }, {passive:true});
  }

  // Helpers globales (opcional)
  window.__setTwoTheme = function(name){ apply(name); };
  window.__toggleTwoTheme = function(){ var now = next(localStorage.getItem(KEY)||'original'); apply(now); return now; };
})();
</script> <script id="theme-rotator-fixed">
document.addEventListener('DOMContentLoaded', function(){
  const KEY = 'logicsoft:theme';
  const html = document.documentElement;
  const btn = document.getElementById('themeBtnTwo');
  if(!btn){ console.warn('[theme] No se encontr√≥ #themeBtnTwo'); return; }

  const THEMES = ['original','logosoft','dark'];
  function apply(theme){
    html.classList.remove('theme-logosoft','theme-dark');
    if(theme === 'logosoft') html.classList.add('theme-logosoft');
    if(theme === 'dark') html.classList.add('theme-dark');
    localStorage.setItem(KEY, theme);
    const label = (theme === 'original' ? 'Original' : (theme === 'logosoft' ? 'LOGOSOFT' : 'Oscuro'));
    btn.title = 'Tema: ' + label;
    btn.setAttribute('aria-label', btn.title);
    // breve feedback visual
    try{
      let toast = document.getElementById('themeToast');
      if(!toast){
        toast = document.createElement('div');
        toast.id = 'themeToast';
        toast.style.position = 'fixed';
        toast.style.right = '12px';
        toast.style.top = '56px';
        toast.style.zIndex = '99999';
        toast.style.padding = '8px 12px';
        toast.style.borderRadius = '10px';
        toast.style.fontWeight = '900';
        toast.style.background = '#000';
        toast.style.color = '#fff';
        toast.style.boxShadow = '0 6px 18px rgba(0,0,0,.3)';
        document.body.appendChild(toast);
      }
      toast.textContent = 'Tema: ' + label;
      toast.style.opacity = '1';
      clearTimeout(window.__themeToastTimer);
      window.__themeToastTimer = setTimeout(()=>{ toast.style.transition='opacity .4s'; toast.style.opacity='0'; }, 900);
    }catch(e){}
  }

  // Load saved theme
  const saved = localStorage.getItem(KEY);
  if(saved && THEMES.includes(saved)){
    apply(saved);
  }else{
    apply('original');
  }

  // Rotate on click
  btn.addEventListener('click', function(){
    const current = localStorage.getItem(KEY) || 'original';
    const idx = THEMES.indexOf(current);
    const next = THEMES[(idx+1) % THEMES.length];
    apply(next);
  });
});
</script> <style id="assistant-hubdot-fixC">
/* SIGNAL: verde ne√≥n en todos los temas */
.hub-dot.signal,
.junction-dot.signal{
  fill: var(--neon) !important;
  stroke: var(--neon) !important;
  filter: drop-shadow(0 0 8px rgba(0,255,136,.55)) !important;
}

/* REPOSO: color del cable (currentColor) */
.hub-dot:not(.signal),
.junction-dot:not(.signal){
  fill: currentColor !important;
  stroke: currentColor !important;
  filter: none !important;
}
</style> <script id="assistant-wire-to-dot-v2">
(function(){
  try{
    const wiresSVG = document.getElementById('wires');
    if(!wiresSVG) return;

    const TOL = 3; // tolerancia para empates
    const near = (a,b,t=TOL)=>Math.abs(a-b)<=t;

    function onSeg(P,a,b){
      if (near(a.x,b.x)){ // vertical
        if (!near(P.x,a.x)) return false;
        const minY = Math.min(a.y,b.y)-TOL, maxY = Math.max(a.y,b.y)+TOL;
        return P.y>=minY && P.y<=maxY;
      } else if (near(a.y,b.y)){ // horizontal
        if (!near(P.y,a.y)) return false;
        const minX = Math.min(a.x,b.x)-TOL, maxX = Math.max(a.x,b.x)+TOL;
        return P.x>=minX && P.x<=maxX;
      }
      return false;
    }

    function parseVerts(pathEl){
      try{
        const d = pathEl.getAttribute('d') || '';
        const nums = d.replace(/[MLZmlz]/g,' ').trim().split(/[^0-9.\-]+/).filter(Boolean).map(Number);
        const pts = [];
        for(let i=0;i+1<nums.length;i+=2) pts.push({x:nums[i], y:nums[i+1]});
        return pts;
      }catch(_){ return []; }
    }

    function hasSignalAtPoint(P){
      const signals = wiresSVG.querySelectorAll('path.wire-path.signal');
      for(const path of signals){
        const pts = parseVerts(path);
        for(let i=1;i<pts.length;i++){
          if (onSeg(P, pts[i-1], pts[i])) return true;
        }
      }
      return false;
    }

    function syncDots(){
      const dots = wiresSVG.querySelectorAll('circle.junction-dot, circle.hub-dot');
      dots.forEach(dot => {
        const cx = parseFloat(dot.getAttribute('cx'));
        const cy = parseFloat(dot.getAttribute('cy'));
        if(isNaN(cx)||isNaN(cy)) return;
        const P = {x:cx,y:cy};
        dot.classList.toggle('signal', hasSignalAtPoint(P));
      });
    }

    // correr ahora y en cambios
    syncDots();
    const mo = new MutationObserver(() => requestAnimationFrame(syncDots));
    mo.observe(wiresSVG, {subtree:true, attributes:true, attributeFilter:['class','d'], childList:true});

    // tambi√©n al simular/detener o redimensionar
    document.getElementById('simulate')?.addEventListener('click', ()=> setTimeout(syncDots, 20));
    document.getElementById('stop')?.addEventListener('click', ()=> setTimeout(syncDots, 20));
    window.addEventListener('resize', ()=> requestAnimationFrame(syncDots));
  }catch(e){ console.error('assistant-wire-to-dot-v2 error', e); }
})();
</script> <script>
(function(){
  const simulateBtn = document.getElementById('simulate');
  const stopBtn = document.getElementById('stop');

  if (simulateBtn && !simulateBtn.dataset.assistPatch) {
    simulateBtn.dataset.assistPatch = '1';
    simulateBtn.addEventListener('click', () => simulateBtn.classList.add('active'));
  }

  if (stopBtn && !stopBtn.dataset.assistPatch) {
    stopBtn.dataset.assistPatch = '1';
    stopBtn.addEventListener('click', () => simulateBtn.classList.remove('active'));
  }
})();
</script> <script id="logicsoft-exporter">
(function(){
  function getBBox(){
    const ws = document.getElementById('workspace');
    if(!ws) return {x:0,y:0,w:1200,h:800};
    const els = Array.from(ws.querySelectorAll('.node, .conn-tag, .badge, .timer-display'));
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    const wr = ws.getBoundingClientRect();
    els.forEach(function(el){
      const r = el.getBoundingClientRect();
      const x = r.left - wr.left;
      const y = r.top  - wr.top;
      const w = r.width, h = r.height;
      if(!isFinite(x) || !isFinite(y) || !isFinite(w) || !isFinite(h)) return;
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x+w);
      maxY = Math.max(maxY, y+h);
    });
    const wires = document.getElementById('wires');
    if (wires && wires.children && wires.children.length){
      try {
        const bb = wires.getBBox();
        minX = Math.min(minX, bb.x);
        minY = Math.min(minY, bb.y);
        maxX = Math.max(maxX, bb.x + bb.width);
        maxY = Math.max(maxY, bb.y + bb.height);
      } catch(e){ /* ignore */ }
    }
    if(!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)){
      return {x:0,y:0,w:1200,h:800};
    }
    const pad = 40;
    return {
      x: Math.max(0, Math.floor(minX-pad)),
      y: Math.max(0, Math.floor(minY-pad)),
      w: Math.ceil((maxX-minX)+pad*2),
      h: Math.ceil((maxY-minY)+pad*2)
    };
  }

  function collectInlineStyles(){
    try{
      return Array.from(document.querySelectorAll('style')).map(function(s){return s.textContent||'';}).join('\n');
    }catch(e){ return ''; }
  }

  const bbox = getBBox();
      const styles = collectInlineStyles();
      const clone = ws.cloneNode(true);
      // Forzar fondo blanco SIEMPRE
      clone.style.background = '#ffffff';

      // Reposicionar el clon para que encaje en (0,0) del SVG
      const offset = `position:relative;left:${-bbox.x}px;top:${-bbox.y}px;`;
      clone.setAttribute('style', (clone.getAttribute('style')||'') + ';' + offset);

      const svgW = Math.max(1, Math.round(bbox.w));
      const svgH = Math.max(1, Math.round(bbox.h));

      const svg =
        `<svg xmlns="http://www.w3.org/2000/svg" width="${svgW}" height="${svgH}">`+
        `<defs><style>${(styles||'').replace(/<\/style>/g,'')}
/* === Ajuste profesional del modal de EDITAR bloque === */
.modal-edit-block {
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    width: 90% !important;
    max-width: 420px !important;
    max-height: 75vh !important;
    overflow-y: auto !important;
    padding: 15px !important;
    border-radius: 14px !important;
    z-index: 9998 !important;
}

/* Contenido interno */
.modal-edit-block input,
.modal-edit-block select,
.modal-edit-block textarea {
    font-size: 15px !important;
    padding: 8px !important;
}

/* T√≠tulo */
.modal-edit-block h2 {
    font-size: 20px !important;
    margin-bottom: 10px !important;
}

/* Botones */
.modal-edit-block button {
    font-size: 15px !important;
    padding: 8px 14px !important;
}

</style></defs>`+
        `<rect x="0" y="0" width="100%" height="100%" fill="#ffffff"/>`+
        `<foreignObject x="0" y="0" width="${svgW}" height="${svgH}">`+
        `<div xmlns="http://www.w3.org/1999/xhtml">`+
        clone.outerHTML +
        `</div>`+
        `</foreignObject>`+
        `</svg>`;

      const svgBlob = new Blob([svg], {type:'image/svg+xml;charset=utf-8'});
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.decoding = 'async';
      img.onload = function(){
        try{
          const canvas = document.createElement('canvas');
          canvas.width = svgW; canvas.height = svgH;
          const ctx = canvas.getContext('2d');
          ctx.imageSmoothingEnabled = true;
          ctx.drawImage(img, 0, 0);
          URL.revokeObjectURL(url);
          const dataURL = canvas.toDataURL('image/png', 1.0);
          const a = document.createElement('a');
          const stamp = new Date().toISOString().replace(/[:.]/g,'-');
          a.download = `logicsoft-${stamp}.png`;
          a.href = dataURL;
          a.click();
        }catch(err){
          URL.revokeObjectURL(url);
          alert('No se pudo exportar la imagen: '+err);
        }
      };
      img.onerror = function(){
        URL.revokeObjectURL(url);
        alert('No se pudo renderizar el SVG. Intenta con otro navegador.');
      };
      img.src = url;
    }catch(e){
      alert(""+e.message);
    }
  }

  // Enlazar bot√≥n
  function bindBtn(){
    var b = document.getElementById('btnExportPNG');
    if(b && !b._pngBound){
      b.addEventListener('click', exportPNG);
      b._pngBound = true;
    }
  }
  bindBtn();
  // Si tu app reconstruye la barra, reintentar
  document.addEventListener('DOMContentLoaded', bindBtn);
  window.addEventListener('load', bindBtn);
})();
</script> <script id="cleanup-css-leak">
(function(){
  function isLeakText(s){
    if(!s) return false;
    s = String(s).toLowerCase();
    return (
      s.includes('border-color:') ||
      s.includes('box-shadow:') ||
      s.includes('/* celeste suave */') ||
      (s.includes('rgba(') && s.includes('!important;') && s.includes('background:'))
    );
  }
  function removeLeaks(root){
    try{
      // 1) Text nodes direct under body
      var body = document.body;
      var toRemove = [];
      body.childNodes.forEach(function(n){
        if(n.nodeType === Node.TEXT_NODE && isLeakText(n.textContent.trim())){
          toRemove.push(n);
        }else if(n.nodeType === Node.ELEMENT_NODE){
          var txt = n.textContent || '';
          // very short elements that only contain the leak
          if(isLeakText(txt) && txt.trim().length < 300){
            toRemove.push(n);
          }
        }
      });
      toRemove.forEach(function(n){ try{ n.remove(); }catch(_){ } });
    }catch(_){}
  }
  function ready(fn){ 
    if(document.readyState !== 'loading') fn(); 
    else document.addEventListener('DOMContentLoaded', fn, {once:true}); 
  }
  ready(function(){
    removeLeaks(document);
  });
  window.addEventListener('load', function(){ removeLeaks(document); });
})();
</script> <script id="perf-optimizations-js">
(function(){
  function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn, {once:true}); }

  ready(function(){
    var body = document.body;
    var workspace = document.getElementById('workspace');

    // 1) Marcar 'dragging' globalmente para desactivar sombras mientras se arrastra
    var dragCounter = 0;
    function onDown(e){
      if(!workspace) return;
      // Si el pointerdown ocurre dentro del √°rea de trabajo o sobre un bloque
      var p = e.target.closest ? e.target.closest('.node, #workspace') : null;
      if(!p) return;
      dragCounter++;
      body.classList.add('dragging');
    }
    function onUp(){
      dragCounter = Math.max(0, dragCounter-1);
      if(dragCounter===0) body.classList.remove('dragging');
    }
    document.addEventListener('pointerdown', onDown, {capture:true});
    document.addEventListener('pointerup', onUp, {capture:true});
    document.addEventListener('pointercancel', onUp, {capture:true});
    document.addEventListener('mouseleave', onUp, {capture:true});

    // 2) Auto‚Äìmodo rendimiento cuando hay muchos nodos/cables
    function countHeavy(){
      var blocks = document.querySelectorAll('.node').length;
      var wires  = document.querySelectorAll('.wire, .cable, .connection').length;
      var heavy = (blocks >= 120) || (wires >= 240);
      body.classList.toggle('perf-lite', heavy);
    }
    // Contar al iniciar y observar cambios
    countHeavy();
    var mo = new MutationObserver(function(muts){
      // Micro‚Äìdebounce
      if(window.__perfCountRAF) cancelAnimationFrame(window.__perfCountRAF);
      window.__perfCountRAF = requestAnimationFrame(countHeavy);
    });
    mo.observe(document.getElementById('canvas') || document.body, {childList:true, subtree:true});

    // 3) Throttle de repaints por pointermove global (solo marca un flag)
    // No tocamos tu l√≥gica; solo evitamos trabajo duplicado por r√°fagas.
    var ticking = false;
    function onPointerMove(){
      if(ticking) return;
      ticking = true;
      requestAnimationFrame(function(){ ticking = false; });
    }
    document.addEventListener('pointermove', onPointerMove, {passive:true});
    document.addEventListener('mousemove', onPointerMove, {passive:true});
    document.addEventListener('wheel', function(){}, {passive:true}); // asegura passive por defecto
  });
})();
</script> <script id="anti-flicker-engine">
(function(){
  // Histeresis: cu√°nto tiempo debe mantenerse el valor para aplicar en UI
  var ON_DELAY_MS  = 40;   // encender necesita 40ms estable
  var OFF_DELAY_MS = 60;   // apagar necesita 60ms estable (ligero hysteresis)

  var last = {}; // id -> {raw:boolean, shown:boolean, t:number}

  function now(){ return performance.now(); }

  function ensureId(el){
    if(!el.id){
      el.id = 'out-' + Math.random().toString(36).slice(2,8);
    }
    return el.id;
  }

  function tick(){
    var t = now();
    var outs = document.querySelectorAll('.node[data-type="output"]');
    outs.forEach(function(el){
      var id = ensureId(el);
      var raw = el.classList.contains('has-signal'); // se√±al "real" del motor
      var st = last[id] || (last[id] = {raw:raw, shown:false, t:t});
      // Si cambi√≥ el crudo, reiniciamos temporizador
      if(raw !== st.raw){
        st.raw = raw;
        st.t = t;
      }
      // ¬øCumpli√≥ umbral?
      var dt = t - st.t;
      if(raw && !st.shown && dt >= ON_DELAY_MS){
        st.shown = true;
        el.classList.add('ui-on');
      }else if(!raw && st.shown && dt >= OFF_DELAY_MS){
        st.shown = false;
        el.classList.remove('ui-on');
      }
    });
    requestAnimationFrame(tick);
  }

  // Iniciar cuando el DOM est√© listo
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){ requestAnimationFrame(tick); }, {once:true});
  }else{
    requestAnimationFrame(tick);
  }
})();
</script> <script id="scan-cycle-buffer">
/* PLC-like scan buffering: apply class 'has-signal' changes once per frame */
(function(){
  var SCAN_ENABLED = true;
  var buf = new Map();                 // element -> desired boolean
  var prev = new WeakMap();            // element -> last applied boolean
  var scheduled = false;
  function applyBuffered(){
    scheduled = false;
    buf.forEach(function(desired, el){
      el.classList.toggle('has-signal', desired);
      prev.set(el, desired);
    });
    buf.clear();
  }
  function schedule(){
    if (!scheduled){
      scheduled = true;
      requestAnimationFrame(applyBuffered);
    }
  }
  function handleMutation(m){
    if (!SCAN_ENABLED) return;
    var el = m.target;
    if (!(el instanceof HTMLElement) || !el.classList) return;
    var nowVal = el.classList.contains('has-signal');
    var last = prev.has(el) ? prev.get(el) : nowVal; // initialize first time
    if (nowVal === last) return;
    // Buffer and revert immediately to last state to avoid cascades in same frame
    buf.set(el, nowVal);
    el.classList.toggle('has-signal', last);
    schedule();
  }
  function seedPrev(){
    document.querySelectorAll('.node').forEach(function(el){
      prev.set(el, el.classList.contains('has-signal'));
    });
  }
  function start(){
    seedPrev();
    var root = document.getElementById('workspace') || document.body;
    var mo = new MutationObserver(function(muts){
      for (var i=0;i<muts.length;i++){
        var m = muts[i];
        if (m.type==='attributes' && m.attributeName==='class'){
          handleMutation(m);
        }
      }
    });
    mo.observe(root, {subtree:true, attributes:true, attributeFilter:['class']});
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', start, {once:true});
  } else {
    start();
  }
})();
</script> <script id="pointer-events-patch">
(function () {
  function $(sel, root){ return (root||document).querySelector(sel); }
  function $all(sel, root){ return Array.from((root||document).querySelectorAll(sel)); }

  if (window.__pointerPatchApplied) return;
  window.__pointerPatchApplied = true;

  const components = $all('.component');
  components.forEach(el => el.setAttribute('draggable','false'));

  // Lista de bloques premium (coincide con la paleta)
  const PREMIUM_TYPES = ['sr','ton','toff'];

  function makeGhost(label){
    const g = document.createElement('div');
    g.textContent = String(label||'').toUpperCase();
    g.style.cssText = [
      'position:fixed','left:0','top:0','transform:translate(-50%,-50%)',
      'padding:6px 10px','font-weight:900','border-radius:10px',
      'background:#ffffff','color:#003366','border:3px solid #003366',
      'pointer-events:none','z-index:9999','font-family:system-ui,Segoe UI,Roboto,Arial'
    ].join(';');
    document.body.appendChild(g);
    return g;
  }

  function clientToWorkspace(cx, cy){
    try {
      if (typeof window.clientToWorkspace === 'function') {
        const p = window.clientToWorkspace(cx, cy);
        if (p && typeof p.x === 'number' && typeof p.y === 'number') return p;
      }
    } catch(e){}
    const ws = $('#workspace') || $('#canvas') || document.body;
    const rect = ws.getBoundingClientRect();
    const x = cx - rect.left + (ws.scrollLeft || 0);
    const y = cy - rect.top  + (ws.scrollTop  || 0);
    return {x, y};
  }

  function createNodeCompat(type, x, y){
    if (typeof window.createNode === 'function') {
      window.createNode(type, x, y);
    } else {
      const ws = $('#workspace') || $('#canvas') || document.body;
      ws.dispatchEvent(new CustomEvent('create-node', { detail: { type, x, y } }));
      console.warn('[PWA Patch] createNode() no encontrada; se emiti√≥ evento "create-node". Integra en tu app si es necesario.');
    }
  }

  function isFullDevice(){
    try { return localStorage.getItem('logicsoft_full_v1') === '1'; }
    catch(e){ return !!window.isFull; }
  }

  let placingType = null;
  let ghost = null;

  components.forEach(comp => {
    let pressTimer = null;
    let pressActive = false;
    let startX = 0;
    let startY = 0;

    comp.addEventListener('pointerdown', (e) => {
      // No permitir insertar bloques mientras la simulaci√≥n est√° activa
      if (typeof simulation !== 'undefined' && simulation) {
        pressActive = false;
        return;
      }
      pressActive = true;
      startX = e.clientX;
      startY = e.clientY;

      // Programamos un "long press" (~220 ms) antes de empezar a arrastrar
      pressTimer = setTimeout(() => {
        if (!pressActive) return;

        const tRaw = comp.dataset.type || comp.getAttribute('data-type') || comp.textContent.trim();
        const t = String(tRaw || '').toLowerCase();
        const esPremium = PREMIUM_TYPES.includes(t);
        const full = isFullDevice();

        if (esPremium && !full){
          // feedback visual sin permitir arrastre (bloques bloqueados)
          comp.classList.add('shake-premium');
          setTimeout(()=>comp.classList.remove('shake-premium'), 300);
          placingType = null;
          if (ghost){ ghost.remove(); ghost = null; }
          return;
        }

        placingType = tRaw;
        components.forEach(c => c.classList.remove('selected'));
        comp.classList.add('selected');
        // Sin pointerCapture para no interferir con el scroll
        // No usamos ghost de vista previa; el bloque aparece al soltar
        ghost = null;
      }, 220);
    });

    // Si el usuario desliza (mueve el dedo) antes de que termine el long-press,
    // cancelamos la acci√≥n y dejamos que la lista se desplace normalmente.
    comp.addEventListener('pointermove', (e) => {
      if (!pressActive || !pressTimer) return;
      const dx = Math.abs(e.clientX - startX);
      const dy = Math.abs(e.clientY - startY);
      if (dx > 6 || dy > 6){
        clearTimeout(pressTimer);
        pressTimer = null;
        pressActive = false;
        components.forEach(c => c.classList.remove('selected'));
      }
    }, { passive: true });

    comp.addEventListener('pointerup', () => {
      pressActive = false;
      if (pressTimer){
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    });

    comp.addEventListener('pointercancel', () => {
      pressActive = false;
      if (pressTimer){
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    });
  });


window.addEventListener('pointermove', (e) => {
    if (!ghost) return;
    ghost.style.left = e.clientX + 'px';
    ghost.style.top  = e.clientY + 'px';
  }, { passive: true });

  function isDropTarget(el){
    if (!el) return false;
    return (el.id === 'canvas' || el.id === 'workspace' || (el.closest && el.closest('#canvas, #workspace')));
  }

  window.addEventListener('pointerup', (e) => {
    if (!placingType) {
      if (ghost) { ghost.remove(); ghost = null; }
      // limpiamos selecci√≥n de la biblioteca aunque solo haya sido scroll
      components.forEach(c => c.classList.remove('selected'));
      return;
    }
    const el = document.elementFromPoint(e.clientX, e.clientY);
    if (isDropTarget(el) && !(typeof simulation !== 'undefined' && simulation)) {
      const pos = clientToWorkspace(e.clientX, e.clientY);
      createNodeCompat(placingType, pos.x, pos.y);
    }
    placingType = null;
    if (ghost) { ghost.remove(); ghost = null; }
    // despu√©s de soltar, limpiamos selecci√≥n en la biblioteca
    components.forEach(c => c.classList.remove('selected'));
  });

  const canvasEl = $('#canvas') || $('#workspace');
  if (canvasEl) {
    canvasEl.addEventListener('touchmove', (e) => {
      if (placingType) e.preventDefault();
    }, { passive: false });
  }
})();
</script> <div id="modalSoporte" class="modal-overlay"> <div class="modal-card"> <h3>Desbloquear TON, TOFF y SR</h3> <p>Elige tu plan de suscripci√≥n para activar los bloques premium o ingresa tu c√≥digo:</p> <div class="option-item" data-plan="mensual"> <span>Suscripci√≥n mensual ‚Äî S/15.00 ‚Äî (6 USD)</span> </div> <div class="option-item" data-plan="anual"> <span>Suscripci√≥n por un a√±o ‚Äî S/35.00 ‚Äî (12 USD)</span> </div> <div class="modal-wa-row"> <button type="button" id="okSoporte">Obtener c√≥digo</button> </div> <div class="codigo-box"> <p>¬øYa tienes un c√≥digo de activaci√≥n?</p> <div class="codigo-row"> <input id="codigoDesbloqueo" type="text" placeholder="Ingresa tu c√≥digo aqu√≠"> </div> <small>El c√≥digo se vincula a este dispositivo.</small> </div> <div class="modal-buttons"> <button type="button" id="cancelSoporte">Cerrar</button> <button type="button" id="btnValidarCodigo">Activar c√≥digo</button> </div> </div> </div>> <script>
(function(){
  // URL de la API de Apps Script (suscripciones)
  const API_URL = "https://script.google.com/macros/s/AKfycbyTbADFU1kLdGeqDFhGjtcVodYI-HvedO5qxiN4IKYUBaVNM_KQkqtumbxybiZa8QHWyw/exec";
  const LOCAL_KEY_FULL    = "logicsoft_full_v1";
  const LOCAL_KEY_DEVICE  = "logicsoft_device_id_v1";
  const LOCAL_KEY_LICENSE = "logicsoft_license_info_v1";

  // ================== LICENCIA: GUARDAR / CARGAR / LIMPIAR ==================
  function saveLicense(info){
    try{
      localStorage.setItem(LOCAL_KEY_LICENSE, JSON.stringify(info));
      localStorage.setItem(LOCAL_KEY_FULL, "1");
    }catch(e){}
  }

  function loadLicense(){
    try{
      const raw = localStorage.getItem(LOCAL_KEY_LICENSE);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch(e){
      return null;
    }
  }

  function clearLicense(){
    try{
      localStorage.removeItem(LOCAL_KEY_LICENSE);
      localStorage.removeItem(LOCAL_KEY_FULL);
    }catch(e){}
  }

  // =================== PARSE FECHAS DEL SHEET ====================
  // Acepta:
  //  - "MM/DD/YYYY HH:MM:SS" (el mes ES el primer n√∫mero)
  //  - "DD/MM/YYYY HH:MM:SS"
  //  - ISO: "2025-12-11T20:24:39"
  function parseSheetDateTime(str){
    if(!str) return null;
    str = String(str).trim();

    // ISO (YYYY-MM-DD...)
    if (/^\d{4}-\d{2}-\d{2}/.test(str)) {
      const dIso = new Date(str);
      return isNaN(dIso.getTime()) ? null : dIso;
    }

    const parts = str.split(/\s+/);
    const datePart = parts[0] || "";
    const timePart = parts[1] || "00:00:00";

    const dBits = datePart.split(/[\/\-]/);
    if (dBits.length !== 3) return null;

    let d1 = parseInt(dBits[0], 10);
    let d2 = parseInt(dBits[1], 10);
    const yyyy = parseInt(dBits[2], 10);
    if (!yyyy || !d1 || !d2) return null;

    let day, month;
    if (d1 > 12 && d2 <= 12){
      // DD/MM/YYYY
      day = d1; month = d2;
    }else if (d2 > 12 && d1 <= 12){
      // MM/DD/YYYY
      month = d1; day = d2;
    }else{
      // Ambos <= 12: asumimos que el PRIMERO es el MES (MM/DD/YYYY)
      month = d1; day = d2;
    }

    const tBits = timePart.split(":");
    const hh = parseInt(tBits[0] || "0", 10);
    const mm = parseInt(tBits[1] || "0", 10);
    const ss = parseInt(tBits[2] || "0", 10);

    const d = new Date(yyyy, month - 1, day, hh, mm, ss);
    return isNaN(d.getTime()) ? null : d;
  }

  function isLicenseExpired(info){
    if (!info || !info.expiresAt) return false;
    const exp = parseSheetDateTime(info.expiresAt);
    if (!exp) return false;
    return (new Date()).getTime() > exp.getTime();
  }

  // ========================= DEVICE ID ==========================
  function getDeviceId(){
    try{
      let id = localStorage.getItem(LOCAL_KEY_DEVICE);
      if(!id){
        if (window.crypto && crypto.randomUUID){
          id = "DEV-" + crypto.randomUUID();
        }else{
          id = "DEV-" + Math.random().toString(36).slice(2);
        }
        localStorage.setItem(LOCAL_KEY_DEVICE, id);
      }
      return id;
    }catch(e){
      return "DEV-unknown";
    }
  }

  // ===================== FULL MODE HELPERS ======================
  function aplicarFullSinAlerta(){
    try{ localStorage.setItem(LOCAL_KEY_FULL, "1"); }catch(e){}
    try{ window.isFull = true; }catch(e){}

    // Actualizar clase CSS general
    if (typeof window.syncFullModeClass === "function"){
      window.syncFullModeClass();
    }else{
      document.body.classList.add("full-mode");
    }

    // Activar bloques premium (TON, TOFF, SR)
    if (typeof activarBloquesFull === "function"){
      activarBloquesFull();
    }

    // Ocultar bot√≥n de soporte si existe
    try{
      var btnSoporte = document.getElementById("btnSoporte");
      if(btnSoporte){
        btnSoporte.style.display = "none";
      }
    }catch(e){}
  }

  function marcarFull(){
    aplicarFullSinAlerta();
    alert("‚úÖ Acceso FULL activado.\nToca el bot√≥n NUEVO para iniciar tu circuito con TON, TOFF y SR.");
  }

  // ================== VALIDAR C√ìDIGO (MANUAL) ===================
  async function validarCodigoDesdeSheet(codigo){
    const device = getDeviceId();
    const payload = { code: (codigo || "").toUpperCase(), deviceId: device };

    let resp;
    try{
      const query = `?code=${encodeURIComponent(payload.code)}&deviceId=${encodeURIComponent(payload.deviceId)}`;
      resp = await fetch(API_URL + query);
    }catch(e){
      alert("No se pudo conectar para validar el c√≥digo. Revisa tu conexi√≥n.");
      return;
    }

    let data;
    try{
      data = await resp.json();
    }catch(e){
      console.error("Respuesta no es JSON:", e);
      alert("Respuesta inesperada del servidor.");
      return;
    }

    // Estados que puede devolver Apps Script:
    // OK, INVALID, INACTIVE, MAX_DEVICES, EXPIRED, ERROR
    const status = (data.status || "").toUpperCase();

    if (status === "OK"){
      const tipo  = data.tipo      || "";
      const vence = data.expiresAt || "";

      const licInfo = {
        code: payload.code,
        deviceId: device,
        tipo: tipo,
        expiresAt: vence
      };
      saveLicense(licInfo);

      // Si por fecha ya estuviera vencida, la tratamos como EXPIRED
      if (isLicenseExpired(licInfo)){
        clearLicense();
        alert("Tu licencia ha vencido." + (licInfo.expiresAt ? "\nVenci√≥ el: " + licInfo.expiresAt : ""));
        return;
      }

      marcarFull();
      if (tipo || vence){
        alert("Licencia v√°lida. Tipo: " + tipo + (vence ? "\nVence: " + vence : ""));
      }
      return;
    }

    if (status === "EXPIRED"){
      clearLicense();
      alert("Tu licencia ha vencido." + (data.expiresAt ? "\nVenci√≥ el: " + data.expiresAt : ""));
      return;
    }

    if (status === "MAX_DEVICES"){
      alert("Este c√≥digo ya alcanz√≥ el n√∫mero m√°ximo de dispositivos permitidos.");
      return;
    }

    if (status === "INACTIVE"){
      alert("Este c√≥digo est√° desactivado. Contacta al vendedor.");
      return;
    }

    if (status === "INVALID"){
      alert("C√≥digo no encontrado.");
      return;
    }

    // Si llega aqu√≠, puede ser ERROR u otro estado desconocido
    alert(data.message || "Error en el servidor. Intenta m√°s tarde.");
  }

  // ============== REVISI√ìN AUTOM√ÅTICA AL INICIAR =================
  async function applyLicenseOnStart(){
    const lic = loadLicense();

    if (!lic){
      clearLicense();
      try{ window.isFull = false; }catch(e){}
      if (typeof window.syncFullModeClass === "function"){
        window.syncFullModeClass();
      }
      return;
    }

    // 1) Chequeo r√°pido local por fecha vencida
    if (isLicenseExpired(lic)){
      clearLicense();
      try{ window.isFull = false; }catch(e){}
      if (typeof window.syncFullModeClass === "function"){
        window.syncFullModeClass();
      }
      alert("‚è∞ Tu licencia ha vencido (" + lic.expiresAt + ").\nPor favor, renueva tu suscripci√≥n.");
      return;
    }

    // 2) Por defecto la aplicamos localmente (por si no hay Internet)
    aplicarFullSinAlerta();

    // 3) Revalidar contra el servidor (para cambios en activo / fecha / etc.)
    const code   = (lic.code || lic.C√≥digo || "").toUpperCase();
    const device = getDeviceId();
    if(!code || !device) return;

    try{
      const query = `?code=${encodeURIComponent(code)}&deviceId=${encodeURIComponent(device)}`;
      const resp  = await fetch(API_URL + query);
      let data;
      try{
        data = await resp.json();
      }catch(e){
        return; // si no viene JSON, dejamos la licencia local como est√°
      }

      const status = (data.status || "").toUpperCase();

      if (status === "OK"){
        const tipo  = data.tipo      || lic.tipo      || "";
        const vence = data.expiresAt || lic.expiresAt || "";

        const updated = {
          code: code,
          deviceId: device,
          tipo: tipo,
          expiresAt: vence
        };
        saveLicense(updated);

        // Re-chequeo por si en el Sheet ahora la fecha ya estuviera vencida
        if (isLicenseExpired(updated)){
          clearLicense();
          try{ window.isFull = false; }catch(e){}
          if (typeof window.syncFullModeClass === "function"){
            window.syncFullModeClass();
          }
          alert("‚è∞ Tu licencia ha vencido (" + updated.expiresAt + ").\nPor favor, renueva tu suscripci√≥n.");
          return;
        }

        aplicarFullSinAlerta();
        return;
      }

      if (status === "EXPIRED"){
        clearLicense();
        try{ window.isFull = false; }catch(e){}
        if (typeof window.syncFullModeClass === "function"){
          window.syncFullModeClass();
        }
        alert("Tu licencia ha vencido." + (data.expiresAt ? "\nVenci√≥ el: " + data.expiresAt : ""));
        return;
      }

      if (status === "INACTIVE"){
        clearLicense();
        try{ window.isFull = false; }catch(e){}
        if (typeof window.syncFullModeClass === "function"){
          window.syncFullModeClass();
        }
        alert("Este c√≥digo est√° desactivado. Contacta al vendedor.");
        return;
      }

      if (status === "INVALID"){
        clearLicense();
        try{ window.isFull = false; }catch(e){}
        if (typeof window.syncFullModeClass === "function"){
          window.syncFullModeClass();
        }
        alert("C√≥digo no encontrado.");
        return;
      }

      // Para MAX_DEVICES u otros errores en el arranque
      // no tocamos la licencia local del dispositivo que ya estaba activo.
    }catch(e){
      // Sin conexi√≥n o error de red: usamos la licencia local
      return;
    }
  }

  // Ejecutar la revisi√≥n autom√°tica cuando cargue el documento
  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", function(){ applyLicenseOnStart(); }, { once:true });
  }else{
    applyLicenseOnStart();
  }

  // Exponer funci√≥n global para el bot√≥n "Activar c√≥digo"
  try { window.validarCodigoDesdeSheet = validarCodigoDesdeSheet; } catch(e){}
})();
</script> <script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    var btnSoporte = document.getElementById('btnSoporte');
    var overlay = document.getElementById('modalSoporte');
    var btnCancel = document.getElementById('cancelSoporte');
    var btnOk = document.getElementById('okSoporte');
    var options = overlay ? Array.prototype.slice.call(overlay.querySelectorAll('.option-item')) : [];
    var inputCodigo = document.getElementById('codigoDesbloqueo');
    var btnValidar = document.getElementById('btnValidarCodigo');

    if(!btnSoporte || !overlay) return;

    var selectedPlan = null;

    function openModal(){ overlay.style.display = 'flex'; }
    function closeModal(){ overlay.style.display = 'none'; }

    btnSoporte.addEventListener('click', function(){
      selectedPlan = null;
      options.forEach(function(o){ o.classList.remove('selected'); });
      if(inputCodigo) inputCodigo.value = "";
      openModal();
    });

    if(btnCancel){
      btnCancel.addEventListener('click', function(){ closeModal(); });
    }

    if(overlay){
      overlay.addEventListener('click', function(e){
        if(e.target === overlay){ closeModal(); }
      });
    }

    if(options && options.length){
      options.forEach(function(opt){
        opt.addEventListener('click', function(){
          options.forEach(function(o){ o.classList.remove('selected'); });
          opt.classList.add('selected');
          selectedPlan = opt.getAttribute('data-plan');
        });
      });
    }

    if(btnOk){
      btnOk.addEventListener('click', function(){
        if(!selectedPlan){
          alert('Selecciona un plan para abrir WhatsApp.');
          return;
        }
        var url = '';
        if(selectedPlan === 'mensual'){
          url = 'https://wa.link/ldnvjy';
        }else if(selectedPlan === 'anual'){
          url = 'https://wa.link/yprp9x';
        }
        if(url){ window.open(url, '_blank'); }
      });
    }

    if(btnValidar){
      btnValidar.addEventListener('click', function(){
        // La validaci√≥n detallada ya est√° en el otro script (API_URL / activarBloquesFull).
        // Aqu√≠ solo disparamos el click del handler original si existe.
        if(typeof window.validarCodigoDesdeSheet === 'function'){
          var codigo = (inputCodigo.value || '').trim();
          if(!codigo){
            alert('Ingresa un c√≥digo de activaci√≥n.');
            return;
          }
          window.validarCodigoDesdeSheet(codigo);
        }
      });
    }
  }catch(e){
    console && console.warn && console.warn('Error inicializando modal soporte:', e);
  }
});
</script> <script>
  function activarBloquesFull(){
    try{ localStorage.setItem("logicsoft_full_v1","1"); }catch(e){}
    if (typeof window.syncFullModeClass === "function"){
      window.syncFullModeClass();
    } else {
      document.body.classList.add("full-mode");
      window.isFull = true;
    }
  }
</script> </body></html> <script>
// ==== Assistant Add-on: Undo (Ctrl+Z) + Edici√≥n de n√∫meros en B/Q/M/I ====

// --- 0) Helpers de UI: crear bot√≥n en topbar ---
(function addUndoButton(){
  const topbar = document.getElementById('topbar');
  if(!topbar) return;
  const btn = document.createElement('button');
  btn.id = 'undoBtn';
  btn.textContent = 'Deshacer ‚§∫';
  btn.title = 'Ctrl+Z';
  btn.addEventListener('click', ()=>undo());
  // Insertar antes de spacer
  const spacer = document.getElementById('spacer');
  topbar.insertBefore(btn, spacer);
})();

// --- 1) Sistema de historial (instant√°neas) ---
let __history = [];
let __historyPtr = -1;
let __historyBusy = false;

function pushHistory(label=''){
  if(__historyBusy) return; // evita push durante import
  try{
    const snap = exportState();
    // cortar rama futura si deshicimos
    if(__historyPtr < __history.length - 1){
      __history = __history.slice(0, __historyPtr + 1);
    }
    __history.push({ data: snap, label });
    __historyPtr = __history.length - 1;
  }catch(e){
    console.warn('No se pudo hacer snapshot:', e);
  }
}

function undo(){
  if(__historyPtr <= 0) return;
  __historyPtr--;
  const entry = __history[__historyPtr];
  if(!entry) return;
  importState(entry.data);
}

document.addEventListener('keydown', (e)=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){
    e.preventDefault();
    undo();
  }
});

// --- 2) Exportar/Importar estado (ligero) ---
function exportState(){
  // Guardamos nodos m√≠nimos + conexiones por √≠ndices de pin
  const nodeDump = nodes.map(n=>{
    const rect = { x: parseFloat(n.el.style.left||'0'), y: parseFloat(n.el.style.top||'0') };
    const inputs = (n.inputs||[]).length;
    return {
      id:n.id, type:n.type, name:n.name, code:n.code||null,
      x:rect.x, y:rect.y,
      delayMs: n.delayMs ?? null,
      q: n.q ?? null,
      inputsCount: inputs
    };
  });
  const conDump = connections.map(c=>{
    const fromIdx = nodes.findIndex(n=>n.output===c.from);
    const toNodeIdx = nodes.findIndex(n=>n.inputs && n.inputs.includes(c.to));
    const toPinIdx = (toNodeIdx>=0) ? nodes[toNodeIdx].inputs.indexOf(c.to) : -1;
    return {
      fromNodeIndex: fromIdx,
      toNodeIndex: toNodeIdx,
      toPinIndex: toPinIdx,
      mode: c.mode || 'wire',
      bends: Array.isArray(c.bends) ? c.bends.map(b=>({x:b.x,y:b.y})) : []
    };
  });
  return {
    nodes: nodeDump,
    connections: conDump,
    counts:{ inputCount, outputCount, memoryCount, blockCodeCount, nextNodeId }
  };
}

function importState(data){
  if(!data) return;
  __historyBusy = true;
  try{
    // limpiar escena
    [...(nodes||[])].forEach(n=> n && n.el && n.el.remove());
    nodes.length = 0;
    // limpiar conexiones y SVG
    (connections||[]).slice().forEach(c=>{ try{ removeConnection(c); }catch{} });
    connections.length = 0;
    // restaurar contadores
    if(data.counts){
      inputCount = data.counts.inputCount||0;
      outputCount = data.counts.outputCount||0;
      memoryCount = data.counts.memoryCount||0;
      blockCodeCount = data.counts.blockCodeCount||0;
      nextNodeId = data.counts.nextNodeId||1;
    }
    // recrear nodos
    const created = [];
    data.nodes.forEach(n=>{
      createNode(n.type, n.x, n.y);
      const nn = nodes[nodes.length-1];
      // Ajustar nombre/c√≥digo exactos (para conservar n√∫meros editados)
      if(n.type==='input' || n.type==='output' || n.type==='M'){
        nn.name = n.name; // como 'I7', 'Q3', 'M2'
        nn.el.querySelector('.label').textContent = n.name;
      }else{
        nn.code = n.code; // 'B123'
        const badge = nn.el.querySelector('.badge');
        if(badge) badge.textContent = n.code;
        nn.el.querySelector('.label').textContent = (nn.type==='not'?'1':
          nn.type==='and'?'&':
          nn.type==='or'?'‚â•1':
          nn.type==='nand'?'&':
          nn.type==='nor'?'‚â•1':
          nn.type==='xor'?'=1':
          nn.type==='xnor'?'‚â†1':
          nn.type==='sr'?'S/R':
          nn.type==='ton'?'TON':
          nn.type==='toff'?'TOFF': (nn.type||'').toUpperCase());
      }
      if(n.delayMs!=null) nn.delayMs = n.delayMs;
      if(n.q!=null) nn.q = n.q;
      nn.id = n.id;
      nn.el.style.left = n.x+'px';
      nn.el.style.top  = n.y+'px';
      created.push(nn);
    });
    // recrear conexiones
    data.connections.forEach(c=>{
      if(c.fromNodeIndex<0 || c.toNodeIndex<0) return;
      const src = created[c.fromNodeIndex];
      const dst = created[c.toNodeIndex];
      if(!src || !dst) return;
      const toPin = dst.inputs[c.toPinIndex] || dst.inputs[0];
      createConnection(src.output, toPin);
      const conn = connections[connections.length-1];
      conn.bends = (c.bends||[]).map(b=>({x:b.x,y:b.y}));
      renderConnection(conn);
      // Si era "label", convierte a etiqueta
      if(c.mode==='label'){
        try{ convertWireToLabel(conn); }catch{}
      }
    });
  
  // Update timer countdown labels
  nodes.forEach(n=>{
    if(n.type==='ton' || n.type==='toff'){
      let disp = n.el.querySelector('.timer-display');
      if(!disp){
        disp=document.createElement('div');
        disp.className='timer-display';
        n.el.appendChild(disp);
      }
      const delay = (n.delayMs ?? 1000);
      let sec = delay/1000;
      if(simulation && n.timerStart){
        const tnow = nowMs();
        let remaining = Math.max(0, delay - (tnow - n.timerStart));
        sec = remaining/1000;
      }
      disp.textContent = sec.toFixed(1) + ' s';
    }
  });

  updateConnections();
  }catch(e){
    console.error('Error al importar estado:', e);
  }finally{
    __historyBusy = false;
  }
}

// Hacer 1er snapshot al cargar
window.addEventListener('load', ()=>setTimeout(()=>pushHistory('init'), 100));

// --- 3) Hookear puntos de cambio para snap autom√°tico ---
(function hookMutations(){
  const _createNode = createNode;
  createNode = function(type,x,y){
    _createNode(type,x,y);
    pushHistory('crear nodo');
  };
  const _removeNode = removeNode;
  removeNode = function(node){
    _removeNode(node);
    pushHistory('eliminar nodo');
  };
  const _createConnection = createConnection;
  createConnection = function(from,to){
    _createConnection(from,to);
    pushHistory('crear conexi√≥n');
  };
  const _removeConnection = removeConnection;
  removeConnection = function(conn){
    _removeConnection(conn);
    pushHistory('eliminar conexi√≥n');
  };
  const _convertWireToLabel = convertWireToLabel;
  convertWireToLabel = function(conn){
    _convertWireToLabel(conn);
    pushHistory('wire‚Üílabel');
  };
})();

// --- 4) Edici√≥n de n√∫meros (B/Q/M/I) con validaci√≥n de unicidad ---
function __parseBQMI(node){
  // Devuelve {prefix, numStr, num}
  if(node.type==='input' || node.type==='output' || node.type==='M'){
    const m = String(node.name||'').match(/^([IQM])(\d+)$/i);
    if(!m) return null;
    return { prefix: m[1].toUpperCase(), numStr: m[2], num: parseInt(m[2],10) };
  }else{
    const m = String(node.code||'').match(/^B(\d{1,})$/i);
    if(!m) return null;
    return { prefix:'B', numStr: m[1], num: parseInt(m[1],10) };
  }
}

function __numberExists(prefix, num, exceptNode){
  return nodes.some(n=>{
    const p = __parseBQMI(n);
    if(!p) return false;
    if(n===exceptNode) return false;
    return p.prefix===prefix && p.num===num;
  });
}

function __formatWithPrefix(prefix, num){
  if(prefix==='B'){
    // Mantener 3 d√≠gitos m√≠nimo para B (001, 042, 999, 1000 sin padding extra)
    const s = String(num);
    return 'B' + (s.length>=3 ? s : ('000'+s).slice(-3));
  }else{
    return prefix + String(num);
  }
}

function renameNodeNumber(node, newNum){
  const p = __parseBQMI(node);
  if(!p) return false;
  if(!Number.isInteger(newNum) || newNum<0) return false;
  if(__numberExists(p.prefix, newNum, node)) return false;

  // Aplicar
  if(p.prefix==='B'){
    node.code = __formatWithPrefix('B', newNum);
    const badge = node.el.querySelector('.badge');
    if(badge) badge.textContent = node.code;
  }else{
    node.name = __formatWithPrefix(p.prefix, newNum);
    const lbl = node.el.querySelector('.label');
    if(lbl) lbl.textContent = node.name;
  }
  // Actualizar etiquetas de conexiones
  try{
    connections.forEach(c=>{
      if(c.mode==='label'){
        // recomputar textos usando helpers existentes
        if(c.srcBranch) c.srcBranch.tagEl.textContent = getDestNameWithPin(c);
        if(c.dstBranch) c.dstBranch.tagEl.textContent = getSourceName(c);
      }
    });
  }catch{}

  // Update timer countdown labels
  nodes.forEach(n=>{
    if(n.type==='ton' || n.type==='toff'){
      let disp = n.el.querySelector('.timer-display');
      if(!disp){
        disp=document.createElement('div');
        disp.className='timer-display';
        n.el.appendChild(disp);
      }
      const delay = (n.delayMs ?? 1000);
      let sec = delay/1000;
      if(simulation && n.timerStart){
        const tnow = nowMs();
        let remaining = Math.max(0, delay - (tnow - n.timerStart));
        sec = remaining/1000;
      }
      disp.textContent = sec.toFixed(1) + ' s';
    }
  });

  updateConnections();
  pushHistory('renombrar n√∫mero');
  return true;
}

// UI: doble clic/tap para editar n√∫meros
function attachNumberEditor(node){
  const targetEls = [];
  if(node.type==='input' || node.type==='output' || node.type==='M'){
    const lbl = node.el.querySelector('.label');
    if(lbl) targetEls.push(lbl);
  }else{
    const badge = node.el.querySelector('.badge');
    if(badge) targetEls.push(badge);
  }
  targetEls.forEach(el=>{
    let lastTap=0;
    const handler = (ev)=>{
      ev.stopPropagation();
      const cur = __parseBQMI(node);
      if(!cur) return;
      const val = prompt(`Nuevo n√∫mero para ${cur.prefix} (actual: ${cur.numStr})`, cur.numStr);
      if(val==null) return;
      const n = parseInt(val,10);
      if(isNaN(n) || n<0){
        alert('N√∫mero inv√°lido.');
        return;
      }
      if(__numberExists(cur.prefix, n, node)){
        alert(`Ya existe ${__formatWithPrefix(cur.prefix, n)}. Debe ser √∫nico.`);
        return;
      }
      if(!renameNodeNumber(node, n)){
        alert('No se pudo cambiar el n√∫mero.');
      }
    };
    el.addEventListener('dblclick', handler);
    el.addEventListener('touchend', (e)=>{
      const now = e.timeStamp || Date.now();
      if(now - lastTap < 350){ handler(e); }
      lastTap = now;
    }, {passive:true});
  });
}

// Hook: cuando se crea un nodo, conectar editor de n√∫meros si aplica
(function hookNumberEditor(){
  const _createNode = createNode;
  createNode = function(type,x,y){
    _createNode(type,x,y);
    const node = nodes[nodes.length-1];
    // Solo para B, I, Q, M
    if(node && (node.type==='input'||node.type==='output'||node.type==='M' || (node.code && /^B/.test(node.code)))){
      attachNumberEditor(node);
    }
  };
  // adjuntar a nodos existentes en caso de proyecto abierto
  window.addEventListener('load', ()=>{
    nodes.forEach(n=>{
      if(n && (n.type==='input'||n.type==='output'||n.type==='M' || (n.code && /^B/.test(n.code)))){
        attachNumberEditor(n);
      }
    });
  });
})();

</script>